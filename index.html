<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<title>Endrey Márk&apos;s personal main page: my projects site</title>
		<link rel="stylesheet" href="assets/menu.css"/>
		<link rel="stylesheet" href="assets/code.css"/>
	</head>
	<body>
		<hr/>
		<ul class="menu">
			<li><a href="index.hu.html">Hungarian version of this personal main page</a></li>
		</ul>
		<hr/>

		<h1>Endrey Márk&apos;s personal main page: my projects site</h1>

		<h2>Table of contents</h2>
		<ul>
			<li>
				<a href="#recent-hs-backend">My most recent Haskell web-related, backend projects</a>
				<ul>
					<li><a href="#live-hs-webapp">Online live webapp sample: language tutoring site with quiz practice series</a></li>
					<li><a href="#hs-web-client">A web client app for a given API. Demonstrating monad transformers</a></li>
				</ul>
			</li>
			<li><a href="#Agda">Projects with theorem provers and dependent types: two very young Agda projects</a></li>
			<li><a href="#calculi">Implementations of mini programming languages/calculi in Haskell. Using zippers</a></li>
			<li><a href="#Haskell-inspired">A Haskell-inspired project, implemented in PHP and JavaScript</a></li>
			<li><a href="#testing">Testing</a></li>
			<li><a href="#text-processing">Testing with shell scripting and text-processing tools</a></li>
			<li>
				<a href="#math">Mathematics, my relationship with math</a>
				<ul>
					<li><a href="#selfref">Samples about self-reference</a></li>
				</ul>
			</li>
			<li><a href="#onliner">My Haskell one-liners, proof-of-concept projects, or other kind of extra-mini projects</a></li>
			<li><a href="#webapp">Functional web apps</a></li>
			<li><a href="#old-non-hs">My old non-Haskell projects</a></li>
			<li><a href="#old-hs">My old Haskell projects</a></li>
		</ul>

	        <h2 id="recent-hs-backend">My most recent Haskell web-related, backend projects</h2>
	        <p>Besides that explicit contentual goals, they also an implicit technical aim: to explore possibilities, the use of functional programming in projects potentially growing very big, posing challanges in keeping architecture clean.</p>
		<h3 id="live-hs-webapp">Online live webapp sample: language tutoring site with quiz practice series</h3>

		<!--p><q>English-German word- and sentence practice</q>: <a href="https://github.com/alignalghii/bilingual-practice-EN" target="_blank">GitHub project page</a> (and as a part: <a href="https://github.com/alignalghii/bilingual-practice-EN#readme">README</a>), furthermore the live online web app <a href="http://bilingual.curlgrep-phantom-funspec.hu:3001" target="_blank">to be seen usable, testable</a>.</p-->
		<p><q>Hungarian-English word- and sentence practice</q>: a quiz-like web app for tutoring English phrases to Hungarian persons. It generates random quiz series for practice out of a large pre-uploaded lexicon dataset. Moreover, the learners can store, manage, review, repeat their former completed practice quizzes, and compare them to see personal progress. (Later user-friendly cherrypicking features will be added, too.)</p>
		<ul>
		    <li>It has its public <a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app" target="_blank">GitHub project page</a> (and as a part of that, some documentation in <a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app#readme">its README</a>),</li>
		    <li>furthermore the live online web app itself <a href="http://bilingual.curlgrep-phantom-funspec.hu:3006" target="_blank">is hosted and can be seen here</a>.</li>
		</ul>
		<p>As for its techological background, this small project intends also to discover and present Haskell&apos;s capabilities in web programming, maybe also its possible advantages in testability and clean coding. As the poject keeps growing, a long-term goal is to see how much <q>mileage</q> is there in functional programming, how its advantages keep going in the long run, and how the prevention of accumating technical dept can be achieved. In more concrete terms, probalby also the role of monad transformers and other architecture-scale techniques will be evaluated and compared with the efficiency of traditional design patterns.</p>
		<p>As for underlying web framework, the <a href="https://github.com/scotty-web/scotty/wiki/Scotty-Tutorials-&-Examples" target="_blank">Scotty</a> micro-webframework is used. And as for a <q>dark corner</q> od the project (at least at testing): despite of modern test tools being intended in future (unit, database, and web API tests), for the time being a DIY-self-hacked bash script autotest provides a rough web API test, in the manner of the (in)famous <q><a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app/blob/main/test/API-client-tester.bash" target="_blank">curl-grep</a></q> style.</p></p>
		<!--p>(As for people having no relations to Hungarian language, especially for native English speakers, this web application has a <q>German-tutoring to English audience</q> variant, see its <a href="https://github.com/alignalghii/bilingual-practice-EN" target="_blank">GitHub project page</a> and live <a="http://bilingual.curlgrep-phantom-funspec.hu:3001">hosted site</a>. But this is yet in a much less developed stage with much less features yet, comaperd to the much more richly featured Hungarian-English in the previous paragraphs above.)</p-->


		<h3 id="hs-web-client">A web client app for a given API. Demonstrating monad transformers</h3>

		<p>After having seen a web application above implemented in Haskell, now let us see an example for the <q>opposite</q>, <q>counterpart</q>:
		a <em>web client</em> application!</p>

		<p>Here is a <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs" target="_blank">client app to Wikipedia&apos;s search API</a> (see also its <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs#readme">README</a>). i have hdone the higher-lever and custom parts of handling Wikipedia&apos;s search API with appropriatelly designed monad transformers, &mdsh; moreover, originally the whole project started to be a demonstration and motivating example for monad transformers (and part of my own personal learning parth towards them).</p>

		<p>As for the lower-level details of HTTP client programming, this project bases upon the <a href="http://www.serpentine.com/wreq/" target="_blank">Wreq</a> library.</p>


		<h2 id="Agda">Projects with theorem provers and dependent types: two very young Agda projects</h2>
		<p>&hellip; showing my most recent knowledge and coding style in theorem provers and Martin-Löf type theory</p>
		<ul>
			<li>
				<span><a href="https://github.com/alignalghii/vector-algebra-in-Agda" target="_blank">Vector algebra in Agda</a> (see also its <a href="https://github.com/alignalghii/vector-algebra-in-Agda#readme">README documentation</a>). Long-term goal is to write a collision detection engine (using the <a href="https://en.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination" target="_blank">Fourier-Motzkin elimination</a>), and making theorems and correctness proofs about it. Of course, this goal is very distant. Current achievements:</span>
				<ul>
					<li>I successfully proved in pure Agda that the <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/Transposition.agda#L50" target="_blank">matrix transposition operation is a self-inverse operation</a>, a so-called involution: done twice is like not done at all.</li>
					<li>I made two alternative definitions for matrix transpsosition, and proved in Agda that the <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/TranspositionAlternative.agda#L36" target="_blank">two approaches are equivalent</a>, despite of having rather orthogonal, distinct inductive structure. The proofs use several restricted tricks of the general <em>function extensionality</em> problem.</li>
					<li>My first attempt for the <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Rational/Unsigned.agda" target="_blank">definition of at least unsigned rational numbers</a> in Agda: it tries to tackle both new challenges on the type level that comes with rationals : 1) rationals must have a type-safe constraint on zero denominator, and 2) they have also a specific equivalence with multiple representations. On top of both challenges, signed rationals pose a new additional challenge, I tried to tackle it by <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Rational/Base.agda" target="_blank">this kind of <q>on-top-of</q> design pattern</a>.</li>
				</ul>
			</li>
			<li><a href="https://github.com/alignalghii/beyond-Haskell" target="_blank">Beyond Haskell</a>. A very early Agda project without definite goals. Presents a coding and proof style, but no particular achievments. Has some interesting parts, and a few existentially quantified theorems about even/odd natural numbers (<a href="https://github.com/alignalghii/beyond-Haskell/blob/main/Theorems/NatModulo.agda#L32" target="_blank">every even number has a half</a>).</li>
		</ul>


		<h2 id="calculi">Implementations of mini programming languages/calculi in Haskell. Using zippers</h2>
		<p><p>An implementation of a mini functional programming language, i.e. a combinatory logic interpreter, with well-organized clean sourcecode. See below in details:</p>
		<ul>
			<li><a href="https://github.com/alignalghii/CL-zipper-RWS" target="_blank">A combinatory logic evaluator</a> (see also its <a href="https://github.com/alignalghii/CL-zipper-RWS#readme">README</a>). My own interpreter for a mini lazy functional programming language, implemented in Haskell. A minimalistic, but still Turing complete functional programming language, having all advantages of being lazy in the term evaluation/ reduction strategy. The implementation tries to be as clean as possible (it uses the zipper technique to achieve the leftmost outermost reduction strategy, thus ensuring lazy evaluation). The main algorithm is a complex but kept conceptually simple with the zipper trick. It does not contain monad transformers for the sake of conceptual simplicity, but it is straitforward to develop it further in this way, and has many motivating prospects to do so (tracing, step counting, infinite runaway check). Work is still in progress, but core parts seem to be complete.</li>
			<li><a href="https://hub.darcs.net/physis/CL-quine" target="_blank">CL-quine</a> (mature): an old, but more featureful combinatory logic interpreter of mine, more user-friendly in use, but with somewhat old and tangled sourcecode. It has also a <q>library</q> of combinators, i.e. a library of combinatory logic itself (i.e. of the target language, and not of Haskell, the meta/host/implementer language). The most sophisitcated combinator here is a full-fledget <em>quine</em>, i.e. an expression of combinatory logic that reduces into its own <q>quotation</q>, i.e. term tree representation in itself. That is exactly the functional counterpart of the familiar imperative <em>quine</em>s, i.e. programs that can print out their own sourcecode without any trick exploiting the operating system or any builtin reflection. (See Wikipedia about <a href="https://en.wikipedia.org/wiki/Quine_(computing)" target="_blank">quines</a>, and see also David Madore&apos;s <a href="http://www.madore.org/~david/computers/quine.html" target="_blank">article</a> about them. Quines are also the main pattern underlying <em>self-reproduction</em>.)</li>
			<li><a href="https://hub.darcs.net/physis/CL-LeftAssocApplTreeZipper/browse/Comb.hs" target="_blank"> CL-LeftAssocApplTreeZipper</a> (experimental): A super-concise implementation of the lazy reduction algorithm. It has not been tested carefully, but maybe it will turn out to be developable further into a nice, compact and efficient combinatry logic interpreter.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#calculi">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="Haskell-inspired">A Haskell-inspired project, implemented in PHP and JavaScript</h2>
		<p><a href="https://github.com/alignalghii/loosely-coupled-figure-editor" target="_blank">Floor plan editor</a> (see also its detailed <a href="https://github.com/alignalghii/loosely-coupled-figure-editor#readme">README doc</a>): a graphics editor web-application for real estate emplyees to help them drawing the floor plans of theirflats. JavaScript on the font-end client-side, and PHP backend. Its most important feature and component, <q>math/physics engine</q> is the collision detection of the world being drawn: rooms, pieces of furniture, windows and doors all collide and slide on each other wen moved realistically. I designed the collision detection Haskell based on Fourier-Motzkin elimination.<!--Lényegi része, motorja az üsközésvizsgálat (<q>fizikai motor</q>), amely Haskellben készült és lett tesztelve. Másik fontos jellegzetessége, hogy kilens oldali része, a JavaScript-szerkesztő maga is az MVC tervezési mintát követi egy házilagos keretrendszerben, kontrollerekkel, sőt afféle <a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/public/app.js">router</a> is létezik egyfajta esemény-nyelvre, ezzel együtt <a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/public/app.js">az analógia szinte teljes</a> a szerver oldali rész klasszikus MVC-architektúrájával. Harmadik fontos vonása a PHP, lletve a javaScript helyenként tiszta Haskell tervezési mintákat vesz át: algebrai adatszerekezetek, monászok, ezek megvalósítására a Scala-ból ismeretes <q>case object</q> technika öröklődéssel való imitálását használja, ebből a legfőbb példák <a href="https://github.com/alignalghii/functional-design-upon-imperative-substrate">külön helyre kiválogatva</a> itt láthatóak együtt.--></p>

		<h2 id="testing">Testing</h2>
		<ul>
			<li>Unit testing: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/UnitTest.hs" target="_blank">sample</a> with its two spec files <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeriesSpec.hs" target="_blank">effectless spec</a> (which is inspecting <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeries.hs" target="_blank">effectless</a>) and <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeriesSpec.hs" target="_blank">effectful spec</a> (which is inspecting <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeries.hs" target="_blank">effectful</a>) as part of my <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs">client program project</a> to the WikiMedia search API. It uses Hspec as a test framework.</li>
			<li>Integration testing: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/IntegrationTest.hs" target="_blank">sample</a> as part of my client program project to the WikiMedia search API. It uses custom Haskell code as test framework.</li>
			<li>Non-functional testing or other special Haskell tests (lazyness, termination checking): <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/LazinessDemo.hs" target="_blank">sample</a> as part of my client program project to the WikiMedia search API. It uses parallelity: the unsafe code is run in one thread and it is controlled by another thread.</li>
		</ul>

		<h2 id="text-processing">Testing with shell scripting and text-processing tools</h2>
		<p>The probably infamous &bdquo;Swiss army knife&rdquo; hacky do-in-yourself tool for testing &bdquo;legacy&rdquo; applications (those not tightly developed for testing): using shell scripts forcibly opening up and exploring an interface to the legacy app. E.g. in case of web apps, by &bdquo;curl&rdquo;-ing it (or forcing any other kind of text reactions frofm it to prepared inputs), and analyizing these with text-processing tools. Infamous &bdquo;curl-grep&rdquo; testing of web API-s can be enhanced by using instead of grep a more sophisticated (Turing complete) text-processing language: e.g. sed, AWK, Perl, Raku. These famous <em>data-driven</em> languages open up a state-machine approach for specifying expected behaviors.</p>
		<p>In simplest throw-away such DIY test frameworks, the testing itself can be done by diff-ing the piped result of AWK/Perl/`sed` scripts against perpared etalon/expectation files.</p>
		<p>The above samples present such little test framework for testing such custom non-standard tasks like checking the validity of small self-made document-formatting tools, auxiliary tools for document maintence, implemented via orchestrated and fine-tuned Linux scripting tools.</p>
		<ul>
			<li>A worked-out <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts" target="_blank">ad hoc (self-hacked) unit test framework (sub)project</a>, together with its very detailed <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts#readme">README doc</a>. This auxiliary subproject is  part of this very GitHub Pages personal profile page that You are reading now! It uses Bash, Perl, AWK and sed.  In summary: Sed is a challenging twin and parallel to AWK and Perl, and all these three tools are very versatile for custom task in checking or maintaining texts or streams. Together  with the „glue” / „orchestrating” power of shell scripts (Bash or Perl), this can be organized together into very custom-made ad hoc test framworks adaptable for any imaginable situations.</li>
			<li>Another, a much smaller and less worked-out <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/tree/main/aux-scripts" target="_blank"> (sub)project</a> for a test framework is also an auxiliary part of a bigger project (the already mentioned client program project to the WikiMedia search API). Also its test framework subproject uses Bash, AWK and sed.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#testing">Hungarian version of this section</a></li>
		</ul>
		<hr/>


		<h2 id="math">Mathematics, my relationship with math</h2>
		<ul>
			<li><a href="Haskell-and-math.en.html">Haskell and mathematics (and the way I relate to them)</a>. A short personal writing about the topic. How can Haskell and mathematics strengthen each other mutually, and why is it necessary to keep an openness towards the whole of mathematics?</li>
			<li><a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/doc/haskell" target="_blank">My rather ad-hoc collision detection solution with Fourier-Motzkin elimination</a>. A nicer and cleaner sourcecode could be achieved with Agda, at least for documentation purposes, because vectors and matrices are apt to be represented with dependent-types. <a href="https://github.com/alignalghii/vector-algebra-in-Agda#readme">The already mentioned Agda project for this</a> is still in infancy, having only theorems about the row-and-column algebra of matrices, transposition, arithmetic.</li>
			<li>A proof in category theory, read on Quora, but formalized into  Gentzen-tysle deduction proof tree by myself</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#math">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h3 id="selfref">Samples about self-reference</h3>
		<ul>
			<li><a href="self-calculus-and-semiself-translation.en.html">Self-calculus and semi-self translation</a>: recursive functions in combinatory logic. A heuristic way to Y fixpoint-combinator. Indirect self-reference.</li>
			<li><a href="file:///home/physis/Documents/my-blog/alignalghii.github.io/let-rec.en.html">My simple page trying to write about formalizing the semantics of the famous lazy let-rec construct</a>. The lazy let-rec construct is important also in itself, and is used both in Swiestra&apos;s attribute grammar article.</li>
			<li><a href="https://github.com/alignalghii/practice-preparations-before-learning-attribute-grammars" target="_blank">My personal first steps</a> in understanding  Wouter Swierstra&apos;s article <a href="https://wiki.haskell.org/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter">Why attribute grammars matter</a>. My personal mini-project to explain the strange-looking let-rec used by the article. It has a very <a href="https://github.com/alignalghii/practice-preparations-before-learning-attribute-grammars#readme">detailed README doc</a>.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#selfref">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="onliner">My Haskell one-liners, proof-of-concept projects, or other kind of extra-mini projects</h2>
		<ul>
			<li><a href="https://github.com/alignalghii/lazy-IO-for-pure-functional-interactivity">Lazy IO interactivity and update-hash</a></li>
			<li><a href="https://github.com/alignalghii/tricky-foldr-oneliner-for-a-complex-query">Tricky foldr order</a></li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#onliner">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="webapp">My abandoned former functional web apps</h2>
		<ul>
			<li>Mostly cliens-side: <a href="https://github.com/alignalghii/Monty-Hall-problem">Monty Hall problem</a>, example for JavaScript in the declaritve style. See the most functional-style part in the <a href="https://github.com/alignalghii/Monty-Hall-problem/blob/main/js/model.js">model</a> module.  Implemented in Javascript, but inspired by Haskell design concepts. Used implementation techniques: <span class="emcode">Maybe</span> and <span class="emcode">Either</span> algebraic datatypes via Scala-style <em>case object</em>s, <span class="emcode">Monad</span> (and <span class="emcode">Eq</span> etc&hellip;) type classes via PHP-style <em>trait</em>s. In case of JavaScript, all these implemented via <em>prototypal inheritence</em>.</li>
			<li>Mostly server-side: <a>Mini Scotty</a>, a Scotty webmicroframework sample</li>
			<li><a href="https://github.com/alignalghii/functional-design-upon-imperative-substrate">Functional design upon imperative substrate</a> (JavaScript, PHP)</li>
			<li>Both-tiers webapp sample: floor plan designer (frontend) with lightweight user and document ERP (backend).</li>
			<!--li>Opposite of a web app: a <a href="https://github.com/alignalghii/sample-search-client-paginated-with-monad-transformers">crawler in Haskell with monad transfomers</a></li-->
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#webapp">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="old-non-hs">My old non-Haskell projects</h2>
		<ul>
			<li><a href="old-projects.html">My old reference works and old projects</a>. Some of my small PHP web apps, with their standalone custom hand-made framework.</li>
		</ul>
		<h2 id="old-hs">My old Haskell projects</h2>
	</body>
</html>
