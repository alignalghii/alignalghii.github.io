<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Personal main page: my projects site</title>
		<link rel="stylesheet" href="assets/menu.css"/>
		<link rel="stylesheet" href="assets/code.css"/>
	</head>
	<body>
		<hr/>
		<ul class="menu">
			<li><a href="index.hu.html">Hungarian version of this personal main page</a></li>
		</ul>
		<hr/>

		<h1>Personal main page: my projects site</h1>

		<h2>Table of contents</h2>
		<ul>
			<li>
				<a href="#">Personal main page: my projects site</a>
				<ul>
					<li><a href="#">Table of contents</a></li>
					<li><a href="#Agda">My most recent projects at all: two very young Agda projects</a></li>
					<li><a href="#recent">My most recent Haskell projects. Using monad transformers</a></li>
					<li><a href="#calculi">Implementations of mini programming languages/calculi. Using zippers</a></li>
					<li><a href="#Haskell-inspired">A Haskell-inspired project, implemented in PHP and JavaScript</a></li>
					<li><a href="#testing">Testing</a></li>
					<li><a href="#text-processing">Testing with shell scripting and text-processing tools</a></li>
					<li>
						<a href="#math">Mathematics, my relationship with math</a>
						<ul>
							<li><a href="#selfref">Samples about self-reference</a></li>
						</ul>
					</li>
					<li><a href="#onliner">My Haskell one-liners, proof-of-concept projects, or other kind of extra-mini projects</a></li>
					<li><a href="#webapp">Functional web apps</a></li>
					<li><a href="#old-non-hs">My old non-Haskell projects</a></li>
					<li><a href="#old-hs">My old Haskell projects</a></li>
				</ul>
			</li>
		</ul>

		<h2 id="Agda">My most recent projects at all: two very young Agda projects</h2>
		<p>&hellip; showing my most recent knowledge and coding style in theorem provers and Martin-Löf type theory</p>
		<ul>
			<li>
				<span><a href="https://github.com/alignalghii/vector-algebra-in-Agda" target="_blank">Vector algebra in Agda</a> (see also its <a href="https://github.com/alignalghii/vector-algebra-in-Agda#readme">README documentation</a>). Long-term goal is to write a collision detection engine (using the <a href="https://en.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination" target="_blank">Fourier-Motzkin elimination</a>), and making theorems and correctness proofs about it. Of course, this goal is very distant. Current achievements:</span>
				<ul>
					<li>I successfully proved in pure Agda that the <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/Transposition.agda#L50" target="_blank">matrix transposition operation is a self-inverse operation</a>, a so-called involution: done twice is like not done at all.</li>
					<li>I made two alternative definitions for matrix transpsosition, and proved in Agda that the <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/TranspositionAlternative.agda#L36" target="_blank">two approaches are equivalent</a>, despite of having rather orthogonal, distinct inductive structure. The proofs use several restricted tricks of the general <em>function extensionality</em> problem.</li>
					<li>My first attempt for the <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Rational/Unsigned.agda" target="_blank">definition of at least unsigned rational numbers</a> in Agda: it tries to tackle both new challenges on the type level that comes with rationals : 1) rationals must have a type-safe constraint on zero denominator, and 2) they have also a specific equivalence with multiple representations. On top of both challenges, signed rationals pose a new additional challenge, I tried to tackle it by <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Rational/Base.agda" target="_blank">this kind of <q>on-top-of</q> design pattern</a>.</li>
				</ul>
			</li>
			<li><a href="https://github.com/alignalghii/beyond-Haskell" target="_blank">Beyond Haskell</a>. A very early Agda project without definite goals. Presents a coding and proof style, but no particular achievments. Has some interesting parts, and a few existentially quantified theorems about even/odd natural numbers (<a href="https://github.com/alignalghii/beyond-Haskell/blob/main/Theorems/NatModulo.agda#L32" target="_blank">every even number has a half</a>).</li>
		</ul>

		<h2 id="recent">My most recent Haskell projects. Using monad transformers</h2>
		<p>&hellip; showing my most recent knowledge and coding style</p>
		<ul>
			<li><a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs" target="_blank">A client app to MediaWiki&apos;s search API</a> (see also its <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs#readme">README</a>). A sample project presenting a  motivating example for monad transformers (part of my own personal learning parth towards them).</li>
			<li>An implementation of a mini functional programming language, i.e. a combinatory logic interpreter, with well-organized clean sourcecode. See below in details:</li>
		</ul>

		<h2 id="calculi">Implementations of mini programming languages/calculi. Using zippers</h2>
		<ul>
			<li><a href="https://github.com/alignalghii/CL-zipper-RWS" target="_blank">A combinatory logic evaluator</a> (see also its <a href="https://github.com/alignalghii/CL-zipper-RWS#readme">README</a>). My own interpreter for a mini lazy functional programming language, implemented in Haskell. A minimalistic, but still Turing complete functional programming language, having all advantages of being lazy in the term evaluation/ reduction strategy. The implementation tries to be as clean as possible (it uses the zipper technique to achieve the leftmost outermost reduction strategy, thus ensuring lazy evaluation). The main algorithm is a complex but kept conceptually simple with the zipper trick. It does not contain monad transformers for the sake of conceptual simplicity, but it is straitforward to develop it further in this way, and has many motivating prospects to do so (tracing, step counting, infinite runaway check).</li>
			<li>An old, but more featureful combinatory logic interpreter, more user-friendly in use, but with somewhat old and tangled sourcecode</li>
			<li>A super-concise implementation (reduction algorithm), but only in early steps, not having any user interface.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#calculi">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="Haskell-inspired">A Haskell-inspired project, implemented in PHP and JavaScript</h2>
		<p><a href="https://github.com/alignalghii/loosely-coupled-figure-editor" target="_blank">Floor plan editor</a> (see also its detailed <a href="https://github.com/alignalghii/loosely-coupled-figure-editor#readme">README doc</a>): a graphics editor web-application for real estate emplyees to help them drawing the floor plans of theirflats. JavaScript on the font-end client-side, and PHP backend. Its most important feature and component, <q>math/physics engine</q> is the collision detection of the world being drawn: rooms, pieces of furniture, windows and doors all collide and slide on each other wen moved realistically. I designed the collision detection Haskell based on Fourier-Motzkin elimination.<!--Lényegi része, motorja az üsközésvizsgálat (<q>fizikai motor</q>), amely Haskellben készült és lett tesztelve. Másik fontos jellegzetessége, hogy kilens oldali része, a JavaScript-szerkesztő maga is az MVC tervezési mintát követi egy házilagos keretrendszerben, kontrollerekkel, sőt afféle <a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/public/app.js">router</a> is létezik egyfajta esemény-nyelvre, ezzel együtt <a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/public/app.js">az analógia szinte teljes</a> a szerver oldali rész klasszikus MVC-architektúrájával. Harmadik fontos vonása a PHP, lletve a javaScript helyenként tiszta Haskell tervezési mintákat vesz át: algebrai adatszerekezetek, monászok, ezek megvalósítására a Scala-ból ismeretes <q>case object</q> technika öröklődéssel való imitálását használja, ebből a legfőbb példák <a href="https://github.com/alignalghii/functional-design-upon-imperative-substrate">külön helyre kiválogatva</a> itt láthatóak együtt.--></p>

		<h2 id="testing">Testing</h2>
		<ul>
			<li>Unit testing: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/UnitTest.hs" target="_blank">sample</a> with its two spec files <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeriesSpec.hs" target="_blank">effectless spec</a> (which is inspecting <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeries.hs" target="_blank">effectless</a>) and <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeriesSpec.hs" target="_blank">effectful spec</a> (which is inspecting <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeries.hs" target="_blank">effectful</a>) as part of my <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs">client program project</a> to the WikiMedia search API. It uses Hspec as a test framework.</li>
			<li>Integration testing: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/IntegrationTest.hs" target="_blank">sample</a> as part of my client program project to the WikiMedia search API. It uses custom Haskell code as test framework.</li>
			<li>Non-functional testing or other special Haskell tests (lazyness, infinite runaway): <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/LazinessDemo.hs" target="_blank">sample</a> as part of my client program project to the WikiMedia search API. It uses parallelity: the unsafe code is run in one thread and it is controlled by another thread.</li>
		</ul>

		<h2 id="text-processing">Testing with shell scripting and text-processing tools</h2>
		<p>The probably infamous &bdquo;Swiss army knife&rdquo; hacky do-in-yourself tool for testing &bdquo;legacy&rdquo; applications (those not tightly developed for testing): using shell scripts forcibly opening up and exploring an interface to the legacy app. E.g. in case of web apps, by &bdquo;curl&rdquo;-ing it (or forcing any other kind of text reactions frofm it to prepared inputs), and analyizing these with text-processing tools. Infamous &bdquo;curl-grep&rdquo; testing of web API-s can be enhanced by using instead of grep a more sophisticated (Turing complete) text-processing language: e.g. sed, AWK, Perl, Raku. These famous <em>data-driven</em> languages open up a state-machine approach for specifying expected behaviors.</p>
		<p>In simplest throw-away such DIY test frameworks, the testing itself can be done by diff-ing the piped result of AWK/Perl/`sed` scripts against perpared etalon/expectation files.</p>
		<p>The above samples present such little test framework for testing such custom non-standard tasks like checking the validity of small self-made document-formatting tools, auxiliary tools for document maintence, implemented via orchestrated and fine-tuned Linux scripting tools.</p>
		<ul>
			<li>A worked-out <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts" target="_blank">ad hoc (self-hacked) unit test framework (sub)project</a>, together with its very detailed <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts#readme">README doc</a>. This auxiliary subproject is  part of this very GitHub Pages personal profile page that You are reading now! It uses Bash, Perl, AWK and sed.  In summary: Sed is a challenging twin and parallel to AWK and Perl, and all these three tools are very versatile for custom task in checking or maintaining texts or streams. Together  with the „glue” / „orchestrating” power of shell scripts (Bash or Perl), this can be organized together into very custom-made ad hoc test framworks adaptable for any imaginable situations.</li>
			<li>Another, a much smaller and less worked-out <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/tree/main/aux-scripts" target="_blank"> (sub)project</a> for a test framework is also an auxiliary part of a bigger project (the already mentioned client program project to the WikiMedia search API). Also its test framework subproject uses Bash, AWK and sed.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#testing">Hungarian version of this section</a></li>
		</ul>
		<hr/>


		<h2 id="math">Mathematics, my relationship with math</h2>
		<ul>
			<li><a href="Haskell-and-math.en.html">Haskell and mathematics (and the way I relate to them)</a>. A short personal writing about the topic. How can Haskell and mathematics strengthen each other mutually, and why is it necessary to keep an openness towards the whole of mathematics?</li>
			<li><a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/doc/haskell" target="_blank">My rather ad-hoc collision detection solution with Fourier-Motzkin elimination</a>. A nicer and cleaner sourcecode could be achieved with Agda, at least for documentation purposes, because vectors and matrices are apt to be represented with dependent-types. <a href="https://github.com/alignalghii/vector-algebra-in-Agda#readme">The already mentioned Agda project for this</a> is still in infancy, having only theorems about the row-and-column algebra of matrices, transposition, arithmetic.</li>
			<li>A proof in category theory, read on Quora, but formalized into  Gentzen-tysle deduction proof tree by myself</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#math">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h3 id="selfref">Samples about self-reference</h3>
		<ul>
			<li><a href="self-calculus-and-semiself-translation.en.html">Self-calculus and semi-self translation</a>: recursive functions in combinatory logic. A heuristic way to Y fixpoint-combinator. Indirect self-reference.</li>
			<li><a href="file:///home/physis/Documents/my-blog/alignalghii.github.io/let-rec.en.html">My simple page trying to write about formalizing the semantics of the famous lazy let-rec construct</a>. The lazy let-rec construct is important also in itself, and is used both in Swiestra&apos;s attribute grammar article.</li>
			<li><a href="https://github.com/alignalghii/practice-preparations-before-learning-attribute-grammars" target="_blank">My personal first steps</a> in understanding  Wouter Swierstra&apos;s article <a href="https://wiki.haskell.org/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter">Why attribute grammars matter</a>. My personal mini-project to explain the strange-looking let-rec used by the article. It has a very <a href="https://github.com/alignalghii/practice-preparations-before-learning-attribute-grammars#readme">detailed README doc</a>.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#selfref">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="onliner">My Haskell one-liners, proof-of-concept projects, or other kind of extra-mini projects</h2>
		<ul>
			<li><a href="https://github.com/alignalghii/lazy-IO-for-pure-functional-interactivity">Lazy IO interactivity and update-hash</a></li>
			<li><a href="https://github.com/alignalghii/tricky-foldr-oneliner-for-a-complex-query">Tricky foldr order</a></li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#onliner">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="webapp">Functional web apps</h2>
		<ul>
			<li>Mostly cliens-side: <a href="https://github.com/alignalghii/Monty-Hall-problem">Monty Hall problem</a>, example for JavaScript in the declaritve style. See the most functional-style part in the <a href="https://github.com/alignalghii/Monty-Hall-problem/blob/main/js/model.js">model</a> module.  Implemented in Javascript, but inspired by Haskell design concepts. Used implementation techniques: <span class="emcode">Maybe</span> and <span class="emcode">Either</span> algebraic datatypes via Scala-style <em>case object</em>s, <span class="emcode">Monad</span> (and <span class="emcode">Eq</span> etc&hellip;) type classes via PHP-style <em>trait</em>s. In case of JavaScript, all these implemented via <em>prototypal inheritence</em>.</li>
			<li>Mostly server-side: <a>Mini Scotty</a>, a Scotty webmicroframework sample</li>
			<li><a href="https://github.com/alignalghii/functional-design-upon-imperative-substrate">Functional design upon imperative substrate</a> (JavaScript, PHP)</li>
			<li>Both-tiers webapp sample: floor plan designer (frontend) with lightweight user and document ERP (backend).</li>
			<li>Opposite of a web app: a <a href="https://github.com/alignalghii/sample-search-client-paginated-with-monad-transformers">crawler in Haskell with monad transfomers</a></li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#webapp">Hungarian version of this section</a></li>
		</ul>
		<hr/>

		<h2 id="old-non-hs">My old non-Haskell projects</h2>
		<ul>
			<li><a href="old-projects.html">My old reference works and old projects</a>. Some of my small PHP web apps, with their standalone custom hand-made framework.</li>
		</ul>
		<h2 id="old-hs">My old Haskell projects</h2>
	</body>
</html>
