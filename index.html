<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>Personal main page: my projects site</title>
		<link rel="stylesheet" href="assets/menu.css"/>
		<link rel="stylesheet" href="assets/code.css"/>
	</head>
	<body>
		<ul class="menu">
			<li><a href="index.hu.html">Hungarian version of this personal main page</a></li>
		</ul>

		<h1>Personal main page: my projects site</h1>

		<h2>Table of contents</h2>
		<ul>
			<li>
				<a href="#math">Mathematics, my relationship with math</a>
				<ul>
					<li><a href="#selfref">Samples about self-reference</a></li>
				</ul>
			</li>
			<li><a href="#calculi">Implementations of mini programming languages/calculi. Using zippers</a></li>
			<li><a href="#recent">My most recent Haskell projects. Using monad transformers</a></li>
			<li><a href="#testing">Testing</a></li>
			<li><a href="#text-processing">Testing with shell scripting and text-processing tools</a></li>
			<li><a href="#onliner">My Haskell one-liners, proof-of-concept projects, or other kind of extra-mini projects</a></li>
			<li><a href="#webapp">Functional web apps</a></li>
			<li><a href="#old-non-hs">My old non-Haskell projects</a></li>
			<li><a href="#old-hs">My old Haskell projects</a></li>
		</ul>

		<h2 id="recent">My most recent projects at all: two very young Agda projects</h2>
		<p>&hellip; showing my most recent knowledge and coding style in theorem provers and Martin-Löf type theory</p>
		<ul>
			<li><a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/Transposition.agda">Vector algebra in Agda</a>. Long-term goal is to write a collision detection engine (using the Furier-Motzkin elimination), and making theorems and correctness proofs about it. Of course, this goal is very distant. Current achievement: I successfully proved in pure Agda that the <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/Transposition.agda#L53">matrix transposition operation is a self-inverse operation</a>, a so-called involution: done twice is like not done at all.</li>
			<li><a href="https://github.com/alignalghii/beyond-Haskell">Beyond Haskell</a>. A very early Agda project without definite goals. Presents a coding and proof style, but no particular achievments. Has some interesting parts, and a few existentially quantified theorems about even/odd natural numbers (<a href="https://github.com/alignalghii/beyond-Haskell/blob/main/Theorems/NatModulo.agda#L32">every even number has a half</a>).</li>
		</ul>

		<h2 id="recent">My most recent Haskell projects. Using monad transformers</h2>
		<p>&hellip; showing my most recent knowledge and coding style</p>
		<ul>
			<li><a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs">A client app to MediaWiki&apos;s search API</a>. A sample project presenting a  motivating example for monad transformers (part of my own personal learning parth towards them).</li>
			<li>The already mentioned, new, yet less featureful, but conceptually clean combinatory logic interpreter, with well-organized clean sourcecode</li>
		</ul>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#recent">Hungarian version of this section</a></li>
		</ul>

		<h2 id="calculi">Implementations of mini programming languages/calculi. Using zippers</h2>
		<ul>
			<li><a href="https://github.com/alignalghii/CL-zipper-RWS">A combinatory logic evaluator</a>. My own interpreter for a mini lazy functional programming language, implemented in Haskell. A minimalistic, but still Turing complete functional programming language, having all advantages of being lazy in the term evaluation/ reduction strategy. The implementation tries to be as clean as possible (it uses the zipper technique to achieve the leftmost outermost reduction strategy, thus ensuring lazy evaluation). The main algorithm is a complex but kept conceptually simple with the zipper trick. It does not contain monad transformers for the sake of conceptual simplicity, but it is straitforward to develop it further in this way, and has many motivating prospects to do so (tracing, step counting, infinite runaway check).</li>
			<li>An old, but more featureful combinatory logic interpreter, more user-friendly in use, but with somewhat old and tangled sourcecode</li>
			<li>A super-concise implementation (reduction algorithm), but only in early steps, not having any user interface.</li>
		</ul>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#calculi">Hungarian version of this section</a></li>
		</ul>

		<h2 id="testing">Testing</h2>
		<ul>
			<li>Unit testing: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/UnitTest.hs">sample</a> with its two spec files <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeriesSpec.hs">effectless spec</a> (which is inspecting <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeries.hs">effectless</a>) and <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeriesSpec.hs">effectful</a> (which is inspecting <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeries.hs">effectful</a>) as part of my <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs">client program project</a> to the WikiMedia search API. It uses Hspec as a test framework.</li>
			<li>Integration testing: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/IntegrationTest.hs">sample</a> as part of my client program project to the WikiMedia search API. It uses custom Haskell code as test framework.</li>
			<li>Non-functional testing or other special Haskell tests (lazyness, infinite runaway): <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/LazinessDemo.hs">sample</a> as part of my client program project to the WikiMedia search API. It uses parallelity: the unsafe code is run in one thread and it is controlled by another thread.</li>
		</ul>

		<h2 id="text-processing">Testing with shell scripting and text-processing tools</h2>
		<p>The probably infamous &bdquo;Swiss army knife&rdquo; hacky do-in-yourself tool for testing &bdquo;legacy&rdquo; applications (those not tightly developed for testing): using shell scripts forcibly opening up and exploring an interface to the legacy app. E.g. in case of web apps, by &bdquo;curl&rdquo;-ing it (or forcing any other kind of text reactions frofm it to prepared inputs), and analyizing these with text-processing tools. Infamous &bdquo;curl-grep&rdquo; testing of web API-s can be enhanced by using instead of grep a more sophisticated (Turing complete) text-processing language: e.g. sed, AWK, Perl, Raku. These famous <em>data-driven</em> languages open up a state-machine approach for specifying expected behaviors.</p>
		<p>In simplest throw-away such DIY test frameworks, the testing itself can be done by diff-ing the piped result of AWK/Perl/`sed` scripts against perpared etalon/expectation files.</p>
		<p>The above samples present such little test framework for testing such custom non-standard tasks like checking the validity of small self-made document-formatting tools, auxiliary tools for document maintence, implemented via orchestrated and fine-tuned Linux scripting tools.</p>
		<ul>
			<li>A worked-out (sub)project with a very detailed <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts#auxiliary-text-check-and-filter-scripts">README doc</a>. The sourcecode of this <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts">auxiliary subproject itself</a> is  part of this very GitHub Pages personal profile page that You are reading now! It uses Bash, Perl, AWK and sed.  In summary: Sed is a challenging twin and parallel to AWK and Perl, and all these three tools are very versatile for custom task in checking or maintaining texts or streams. Together  with the „glue” / „orchestrating” power of shell scripts (Bash or Perl), this can be organized together into very custom-made ad hoc test framworks adaptable for any imaginable situations.</li>
			<li>Another, smaller <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/tree/main/aux-scripts"> (sub)project</a> for a test framework is also an auxiliary part of a bigger project (the already mentioned client program project to the WikiMedia search API). Also its test framework subproject uses Bash, AWK and sed.</li>
		</ul>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#testing">Hungarian version of this section</a></li>
		</ul>


		<h2 id="math">Mathematics, my relationship with math</h2>
		<ul>
			<li><a href="Haskell-and-math.en.html">Haskell and mathematics (and the way I relate to them)</a>. A short personal writing about the topic. How can Haskell and mathematics strengthen each other mutually, and why is it necessary to keep an openness towards the whole of mathematics?</li>
			<li><a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/doc/haskell">My rather ad-hoc collision detection solution with Fourier-Motzkin elimination</a>. A nicer and cleaner sourcecode could be achieved with Agda, at least for documentation purposes, because vectors and matrices are apt to be <a href="">represented with dependent-types</a>.</li>
			<li>Agda sample for dependent types, also a very simple Agda proof</li>
			<li>A proof in category theory, read on Quora, but formalized into  Gentzen-tysle deduction proof tree by myself</li>
		</ul>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#math">Hungarian version of this section</a></li>
		</ul>

		<h3 id="selfref">Samples about self-reference</h3>
		<ul>
			<li><a href="self-calculus-and-semiself-translation.en.html">Self-calculus and semi-self translation</a>: recursive functions in combinatory logic. A heuristic way to Y fixpoint-combinator. Indirect reference.</li>
			<li><a href="file:///home/physis/Documents/my-blog/alignalghii.github.io/let-rec.en.html">My simple page trying to write about formalizing the semantics of the famous lazy let-rec construct</a>. The lazy let-rec construct is important also in itself, and is used both in Swiestra&apos;s attribute grammar article.</li>
			<li><a href="https://github.com/alignalghii/practice-preparations-before-learning-attribute-grammars">My personal first steps</a> in understanding  Wouter Swierstra&apos;s article <a href="https://wiki.haskell.org/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter">Why attribute grammars matter</a>. My personal mini-project to explain the strange-looking let-rec used by the article.</li>
		</ul>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#selfref">Hungarian version of this section</a></li>
		</ul>

		<h2 id="onliner">My Haskell one-liners, proof-of-concept projects, or other kind of extra-mini projects</h2>
		<ul>
			<li><a href="https://github.com/alignalghii/lazy-IO-for-pure-functional-interactivity">Lazy IO interactivity and update-hash</a></li>
			<li><a href="https://github.com/alignalghii/tricky-foldr-oneliner-for-a-complex-query">Tricky foldr order</a></li>
		</ul>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#onliner">Hungarian version of this section</a></li>
		</ul>

		<h2 id="webapp">Functional web apps</h2>
		<ul>
			<li>Mostly cliens-side: <a href="https://github.com/alignalghii/Monty-Hall-problem">Monty Hall problem</a>, example for JavaScript in the declaritve style. See the most functional-style part in the <a href="https://github.com/alignalghii/Monty-Hall-problem/blob/main/js/model.js">model</a> module.  Implemented in Javascript, but inspired by Haskell design concepts. Used implementation techniques: <span class="emcode">Maybe</span> and <span class="emcode">Either</span> algebraic datatypes via Scala-style <em>case object</em>s, <span class="emcode">Monad</span> (and <span class="emcode">Eq</span> etc&hellip;) type classes via PHP-style <em>trait</em>s. In case of JavaScript, all these implemented via <em>prototypal inheritence</em>.</li>
			<li>Mostly server-side: <a>Mini Scotty</a>, a Scotty webmicroframework sample</li>
			<li><a href="https://github.com/alignalghii/functional-design-upon-imperative-substrate">Functional design upon imperative substrate</a> (JavaScript, PHP)</li>
			<li>Both-tiers webapp sample: floor plan designer (frontend) with lightweight user and document ERP (backend).</li>
			<li>Opposite of a web app: a <a href="https://github.com/alignalghii/sample-search-client-paginated-with-monad-transformers">crawler in Haskell with monad transfomers</a></li>
		</ul>
		<ul class="menu">
			<li><a href="#top">Jump to top of this page</a></li>
			<li><a href="index.hu.html#webapp">Hungarian version of this section</a></li>
		</ul>

		<h2 id="old-non-hs">My old non-Haskell projects</h2>
		<ul>
			<li><a href="old-projects.html">My old reference works and old projects</a>. Some of my small PHP web apps, with their standalone custom hand-made framework.</li>
		</ul>
		<h2 id="old-hs">My old Haskell projects</h2>
	</body>
</html>
