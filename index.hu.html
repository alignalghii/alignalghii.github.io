<!DOCTYPE html>
<html lang="hu">
	<head>
		<meta charset="UTF-8"/>
		<title>Endrey Márk személyes főoldala: projektjem oldala</title>
		<link rel="stylesheet" href="assets/menu.css"/>
		<link rel="stylesheet" href="assets/code.css"/>
	</head>
	<body>
		<hr/>
		<ul class="menu">
			<li><a href="index.html">E személyes főoldal angol változata</a></li>
		</ul>
		<hr/>

		<h1>Endrey Márk személyes főoldala: projektjem oldala</h1>

		<h2>Tartalom</h2>
		<ul>
			<li>
				<a href="#recent-hs-backend">Webbel kapcsolatos legfrissebb backend projektjeim Haskellben</a>
				<ul>
					<li><a href="#live-hs-webapp">Online kipróbálható élő webalkalmazás-mintapelda</a></li>
					<li><a href="#hs-web-client">Adott külső API-hoz készült webkliens projekt. Az ún. <q>monásztranszformálók</q> hasznosítása.</a></li>
				</ul>
			</li>
			<li><a href="#Agda">Legújabb mindenkori projektjeim: két nagyon újonc Agda-projekt</a></li>
			<li><a href="#calculi">Mini programnyelvek (<q>kalkulusok</q>) megvalósítása interpreterként. Háttér: zipper-adatstruktúrák használata</a></li>
			<li><a href="#Haskell-inspired">Egy Haskell által ihletett projekt, de PHP-ban és JavaScript-ben megvalósítva</a></li>
			<li><a href="#testing">Tesztelés</a></li>
			<li><a href="#text-processing">Shell-szkriptekkel, héjprogramokkal végzett eseti testreszabott tesztelés, szövegfeldolgozó eszközök</a></li>
			<li>
				<a href="#math">Matematika, és a hozzá való viszonyom</a>
				<ul>
					<li><a href="#selfref">Minták az önhivatkozás témakörében: matematikai, logikai vagy lambda-kalkulusbeli ún. önhivatkozási konstrukciók példái</a></li>
				</ul>
			</li>
			<li><a href="#onliner">Haskell ujjgyakorlataim, <q>egysorosok</q>, kis alapkoncepciópróbálkozások, vagy egyéb csonkprojektecskék</a></li>
			<li><a href="#webapp">Funkcionális nyelven írt webalkalmazások</a></li>
			<li><a href="#old-non-hs">My old non-Haskell projects</a></li>
			<li><a href="#old-hs">My old Haskell projects</a></li>
		</ul>

		<h2 id="recent-hs-backend">Webbel kapcsolatos legfrissebb backend projektjeim Haskellben</h2>
		<p>Közvetlen tartalmi céljuk mellett, mindkét itt bemutatott projekt születése mögött áll egy kimondatlan technikai indíték is: kikutatatni, hogy hosszútávon hogyan érvénesülnek, hasznosulnak a funkcionális programozás előnyei potenciéisan a jövőben esetleg nagyra növő, a technikai adósság szempszögéből nézve kihívó projektek esetében, miképp tartható az architektúra átláthatósága.</p>
		<h3 id="live-hs-webapp">Online kipróbálható élő webalkalmazás-mintapelda a funkcionális programozás használatára backend terén</h3>

		<!--p><q>Angol-német szó- és mondatgyakorló</q>: <a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app" target="_blank">GitHub-os projekt oldal</a> (ezen belül külön: <a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app#readme">README</a>), továbbá maga az élőszerverre telepített <a href="http://bilingual.curlgrep-phantom-funspec.hu:3000" target="_blank">élő kipróbálható online webalkalmazás</a>. E projekt technikailag a Haskell webprogramozás lehetőségeinek feltérképezésére indult (Scotty mikro-keretrendszer használata). Tartalmilag pedig nyelvtanulást segítő, gyakorlósorokat, fordítási kvízeket kezelő webalkalmazásról van szó.</p-->
		<p><q>Angol-német szó- és mondatgyakorló</q> webalkalmazás angol nyelvet tanuló magyar felhasználók részére: a gyakorlás segítése véletlensszerűen generálható kvíz-szerű gyakorlósorokkal, amelyek tárolhatóak, utólag is visszanézhetőek, megismételhetőek, továbbalakíthatóak, és személyes fejlődést, összevetéseket is lehetővé tesznek.</p>
		<ul>
		    <li>Forráskódi rész: <a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app" target="_blank">GitHub-os projekt oldal</a> (ezen belül külön: <a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app#readme">README</a>),</li>
		    <li>továbbá maga az élőszerverre telepített <a href="http://bilingual.curlgrep-phantom-funspec.hu:3000" target="_blank">élő kipróbálható online webalkalmazás</a>. (Ennek van az angol anyanyelvű közönség számára is megtekinthető <a href="http://bilingual.curlgrep-phantom-funspec.hu:3006" target="_blank">változata</a>.)
		</ul>
		<p>E projekt technikailag a Haskell webprogramozás lehetőségeinek feltérképezésére indult (Scotty mikro-keretrendszer használata). Hosszú távon majd megnézzük, ahogy nő a projekt, mennyi a hozadéka a funkcionális programozásnak, mennyiben segít a tecnhikai adósság megelőzésében, tesztelhetőségben, öndokumentációban, egészében véve a tiszta kódolásban: a nagyléptékű architekturát mennyivel teszi átláthatóbbá az itt szokásos eszközkészlet (pl. a monásztranszformálók tecnhikája) összevetve a <q>hagyományos</q> tervezési mintákkal.</p>
		<p>Felhasznált keretrendszer: a jellegzetes Haskell-mikrokeretrendszerként ismert <a href="https://github.com/scotty-web/scotty/wiki/Scotty-Tutorials-&-Examples" target="_blank">Scotty</a>. Ami pedig a projekt egy <q>sötét sarkát</q> illeti (legalábbis az automata tesztelésnél): a jövőben tervezett korszerű eszközök, egységtesztek, adatbázistesztek és web API tesztk ellenére, jelenleg a projekt web API-jának durva automata tesztelését egyelőre egy kézi hackelésű, a híres-hírhedt <q><a href="https://github.com/alignalghii/bilingual-Hungarian-English-practice-quiz-app/blob/main/test/API-client-tester.bash" target="_blank">curl-grep</a></q> stílusú bash technikán alapló shellscript teszt biztosítja.</p>

		<h2 id="hs-web-client">Adott külső API-hoz készült webkliens projekt. Az ún. <q>monásztranszformálók</q> hasznosítása.</h2>
		<p>Miután itt elébb föntebb láttunk példát webalkalmazásra Haskell megvalósításban, most nézzünk példát az <q>ellentétére</q>: valósítsunk meg <em>webkliens-alkalmazást</em> Haskellben!</p>
		<p>Íme <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs" target="_blank">kliensalkalmazás a Wikipédia keresőfelületének API-jához</a> (lásd még a részletes <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs#readme">README dokumentációt</a>). Mintaprojekt webes API-kilensre, ahol a Wikipédia keresőfelülethez való kapcsolódás egyedi és magasabb szintű részleteinek kidolgozásához monásztranszformálókat használok, &mdash; sőt eredetileg maga a projekt is épp a monásztranszformálók bemutatásának afféle motiváló példájaként indult el. Bemutatja azt a személyes tanulási utamat is, ahogy e fogalommal megismerkedtem.</p>

		<p>A HTTP-kliensprogramozás alacsonyabbszintű kezeléséhez alapul használt könyvtár pedig a <a href="http://www.serpentine.com/wreq/" target="_blank">Wreq</a>.</p>

		<h2 id="Agda">Legújabb mindenkori projektjeim: két nagyon újonc Agda-projekt</h2>
		<p>&hellip; azt mutatja be, mivel fogalkoztam a legutóbbi hónapban: tudásom és kódolási stílusom tételbizonyító rendszerekben, Martin-Löf tíuselméletben</p>
		<ul>
			<li>
				<span><a href="https://github.com/alignalghii/vector-algebra-in-Agda" target="_blank">Vektoralgebra Agdában</a> (lásd még a részletes <a href="https://github.com/alignalghii/vector-algebra-in-Agda#readme">README dokumentációt</a> is). A projekt hosszútávú célja, hogy helyességbizonyítási támogatást nyújtson egy ütközésvizsgálati virtuálisfizika-könyvtárhoz (az ún.  <a href="https://en.wikipedia.org/wiki/Fourier%E2%80%93Motzkin_elimination" target="_blank">Fourier-Motzkin kiköszöbölési</a> eljárás alapján): lehessen tételeket felállítani és bizonyítani a témakör egésze terén. Természetesen e cél elérése még távol áll e projekttől. A jelenleg is megvalósult eredmények:</span>
				<ul>
					<li>Sikeresen bizonyytottam tisztán Agdában, hogy a <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/Transposition.agda#L50" target="_blank">mátrix-transzponálás az ún. ön-inverz művelet operation</a>, másszóval <a>involúció</q>: kétszer egymás után végzett mátrixtranszponálás épp az eredeti mátrixot adja vissza.</li>
					<li>Két különböző de egyenértékű alternatív definíciót adtam a mátrixtranszponálás megvalósítására, és bebizonyítottam Agdában, hogy <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Vec/Matrix/TranspositionAlternative.agda#L36" target="_blank">e két megközelítés valóban egyenértékű</a>, mindamellet hogy ezek meglehetősen ortogonális, független építkezésmódú megközelítések (így indukciós felépülési szerkezetük is teljesen különböző). A különböző indukcós szerkezt miatt a bizonyítások érintik az ún. <em>függvény-extenzionalitás</em> (funExt) problémakörét, és mivel ez az Agdában általánosságban nincs támogatva, így a bizonyítás ennek a korlátozott, konkrét strukturákra testreszabott változatát használja, amelyenek az Agdában több érdekes megjelenési példája is van.</li>
					<li>Első kísérletem arra, hogy legalább az <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Rational/Unsigned.agda" target="_blank">előjel néküli racionális számokat definiáljam Agdában</a>, miközben két velük megjelenő új kihívást kell a típusrendszer szintjén, típusbiztosan megoldani: 1) a racionális számok ábrázolásában 0-nevezőt típusbiztos megszorításnak fordítási időben is kell kizárni tudnia, és 2) a racionális számok azonosságát az ábrázolási forma ekvivalenciaosztályain értelmezzük &mdas; egy adott racionális számot több ekvivalens alak képviseli. Mindkét elébbi kihívás felett egy új további kihívást hoz az előjeles racionális számok felé való továbbépítkezés, ennek típusbiztos megvalósítását az alábbi <a href="https://github.com/alignalghii/vector-algebra-in-Agda/blob/main/Rational/Base.agda" target="_blank">this kind of <q>ráépítkezős</q> tervezési mintával</a> igyekeztem megoldani.</li>
				</ul>
			</li>
			<li><a href="https://github.com/alignalghii/beyond-Haskell" target="_blank">A Haskell nyelven túl</a>. Határozott célkitűzések nélküli, nagyon korai Agda-projekt. Arra alkalmas lehet, hogy stílusjegyeimet bemutassa az Agda-kódolás, az intuicionista bizonyításterén. Az egyébként a bevezető szintű tételek szintjét meg nem haladó anyag az alkalmazott jlölési stílus, egyedi konvenciók terén mutat néhány érdekes részt, továbbá az egzisztenciális kvantorok használatában is tartalmaz néhány egyébként igen minimalisztikus példát, például: induktívan váltakozóan definiált páros és páratlan számok, illetve (<a href="https://github.com/alignalghii/beyond-Haskell/blob/main/Theorems/NatModulo.agda#L32" target="_blank">minden így definiált páros szám felbontható két azonos <q>félrész</q> összegére</a> (minden párosnak van fele).</li>
		</ul>

		<h2 id="calculi">Mini programnyelvek (<q>kalkulusok</q>) megvalósítása interpreterként. Háttér: zipper-adatstruktúrák használata</h2>
		<ul>
			<li>
				<span><a href="https://github.com/alignalghii/CL-zipper-RWS" target="_blank">Egy kombinátorlogikai kifjezéseket kiértékelő program &mdash; lényegében interpreter</a> (lásd részleteiben a <a href="https://github.com/alignalghii/CL-zipper-RWS#readme">README dokumentációt</a> is). Saját interpreterem egy mini és lusta kiértékelésű funcionális kalkulusnyelvre, Haskellben megvalósítva. Minimalisztikus, de  Turing-teljes funkcionális programnyelv, ha normál-sorrendi kiértékelési/redukciós stratégia révén a lusta adatszerkezetek és kiértékelés minden előnyét tudja nyújtani elvileg.</span>
				<br/>
				<span>Magát a technikai megvalósítási részleteket is igyekeztem lehetőleg tiszta koncepciók alapján megírni: a kifejezésfák redukciós lépéseinek követését az ún zipper-adatszerkezet képezi le (<q>lyukas / fókuszálható</q> fastruktúra a lustaságot biztosító ún. <em>legbalsó-legkülső</em> redukciós stratégia megvalósítására). Bár a fő megvalósító agoritmus mindenképp összetett, de a zipper adatszerkezet révén fogalmilag egyszerű és kompakt egységbe fogható össze.
				<br/>
				A megvalósítás nem alkalmaz jelnleg monásztranszformálókat: a fogalmi egyszerűség végett ún. <q>hatások</q> nem szerpelnek a kis programnyelv-kalkulus szolgáltatásai között, de a projekt maga természetes módon adja magát egy ilyyen irányú továbbfejlesztés felé is, aés erre rengeteg ezt motiváló kilátás van: pl. nyomkövetési funkció (log, &mdash; író-monász), lépészámlálási funkció (végtelen divergálás elkaphatósága, esetleg éta-konverziós funExt-bővítés &mdash; állapot-monász, ), meta- és lokális változók (állapot-monász), konfigurálhatóság (olvasó-monász).</span>
			</li>
			<li>Van egy sokkal korábbi, már elég öreg forráskódú és stílusú, kissé darabosabb tsztaságú kombinátorlogikai iterpreterem is, de ez viszont az évek feljesztései alatt sokkal több funkcionalitást nyújt, mint az elébbeni újabb, tisztább forráskódú változat. Ennek megfelelően felhasználóbarátabb is, nyújt bizonyos komputerlagebrai szolgáltatásokat is: a definiált kombinátorok elnevezhetőek, az összetett kombinátorokat szerkezetelemzi és beszédes nevű összetevőkre bontva írja ki.</li>
			<li>Egy harmadik kombinátorlogikai interpreter pedig még teljesen kísérleti jellegű: forráskódja még a zipperadatstruktúrás változaténál is letisztultabb és tömörebb (a redukálási algoritmus termén), viszont még teljesen higányzanak a felhasználói felületek, a mgemgjelenítés, szóval minden más rész.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Ugrás ez oldal tetejére</a></li>
			<li><a href="index.html#calculi">E szakasz angol változata</a></li>
		</ul>
		<hr/>

		<h2 id="Haskell-inspired">Egy Haskell által ihletett projekt, de PHP-ban és JavaScript-ben megvalósítva</h2>
		<p><a href="https://github.com/alignalghii/loosely-coupled-figure-editor" target="_blank">Alaprajztervező</a> (lásd még a <a href="https://github.com/alignalghii/loosely-coupled-figure-editor#readme">README dokumentációt</a>): egy vektorgrafikus szerkesztőprogramot nyújtó webalkalmazás ingatlanirodák allalmazottainak munkáinak segítésére: a vállalt lakások alaprajzainak önálló elkészítése. JavaScript a frontenden kilensoldalon, és pHP backend.<br/>Legfontosabb vonása és komponense a <q>matematikai-fizikai motor</q> azaz egy ütközésvizsgáló a rajzolt világ <q>tárgyai</q> között: zobák, bútorok, nyílászárók mind a saját szabályuk szerint ütköznek, részben a felhasználói célszerűség, részben a fizikai realizmus elveit követve: a tárgyak elvágólagosan is elrendezhetőek kényelmesen, és egymás felületén relisztikusan elcsúsztathatóak. Az ütközésvizsgálót eredetileg Haskellben terveztem egyszerű, optimalizációmentes, de világos matematikai háttérrel (az ismert ún. Fourier-Moztkin kiküszöbölési eljárás lekódolásával), és innen lett átültetve JavaSceipt kódba a Scala és Smalltalk programozók által ismert case-object technika révén, amely a Haskell algebrai adattípusait szinte gépiesen képes örökődő oztályhierarchiák nyelvére átültetni.
<!--Lényegi része, motorja az üsközésvizsgálat (<q>fizikai motor</q>), amely Haskellben készült és lett tesztelve. Másik fontos jellegzetessége, hogy kilens oldali része, a JavaScript-szerkesztő maga is az MVC tervezési mintát követi egy házilagos keretrendszerben, kontrollerekkel, sőt afféle <a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/public/app.js">router</a> is létezik egyfajta esemény-nyelvre, ezzel együtt <a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/public/app.js">az analógia szinte teljes</a> a szerver oldali rész klasszikus MVC-architektúrájával.--> ennek megfelelően a kódban a PHP, lletve a JavaScript modulok is helyenként tiszta Haskell tervezési mintákat vesz át: algebrai adatszerekezetek, monászok, ezek megvalósítására a Scala-ból ismeretes <q>case object</q> technika öröklődéssel való imitálását használja, ebből a legfőbb példák <a href="https://github.com/alignalghii/functional-design-upon-imperative-substrate">külön helyre kiválogatva</a> itt láthatóak együtt.</p>

		<h2 id="testing">Tesztelés</h2>
		<ul>
			<li>Egységtesztelés: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/UnitTest.hs" target="_blank">minta</a> két Spec-állománnyal <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeriesSpec.hs" target="_blank">effectless spec</a> (ez az <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectless/PaginationConceptSeries.hs" target="_blank">effectless</a> modult teszteli), továbbá az <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeriesSpec.hs" target="_blank">effectful spec</a> (ez pedig az <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/PaginationStateMachines/Effectful/PaginationConceptSeries.hs" target="_blank">effectful</a> modult teszteli) &mdash; mindez a már említett <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs">Wikipédia-kereső-API-hoz írt kilensprogram</a> része. A felhasznált teszt-keretrendszer: a Hspec.</li>
			<li>Integrációs tesztelés: <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/IntegrationTest.hs" target="_blank">sample</a> &mdash; ez is része a már elmített Wikipédia-kereső-API-hoz írt kilensprogramnak. Az integrációs teszt nem használ külön szabványos tesztkeretrendszert, hanem e céllra írt egyedi Haskell-kódot.</li>
			<li>Nem-funkcionális tesztelés, illetve más különleges esetű Haskell-tesztek  (lusta kiértékelődés vizsgálata, sikeres terminálás vs divergálás vizsgálata): <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/blob/main/src/MetaFeatures/LazinessDemo.hs" target="_blank">sample</a> &mdash; ez is része a már elmített Wikipédia-kereső-API-hoz írt kilensprogramnak. e különleges dolgok teszteléséhez természetesen <em>párhuzamosságot</em> használtam: az <q>unsafe</q> kód külön szálban fut, és egy másik külön szál felügyeli őt a teszt éredkében.</li>
		</ul>

		<h2 id="text-processing">Shell-szkriptekkel, héjprogramokkal végzett eseti testreszabott tesztelés, szövegfeldolgozó eszközök</h2>
		<p>A híres-hírhedt <q>svájcibicska</q>, hackelős-házilagos teszteszköz <q>legacy</q> alkalmazások tesztelésére (vagyis maleyket nem fejleszettek folyamotosan tesztelésre nyitottságra): egyedi testreszabott shlell-szkriptek <q>törik fel</q>, <q>nyitják meg</q> őket (néha erőből is) hogy felkutassák a felhasználó felületet vagy más kívülről elérhető vagy feltörhető felületét a legacy alkalmazásnak.<br/>Például webalkalmazások esetében, a felhasználó felület kovetkezetes  &bdquo;curl&rdquo;-scriptes lekérdezése (avagy szöveges reaglás bármi módon való kifacsarása módszeresen előkészített inputok alapján), és a ki-curl-özött válaszok szövegfeldolgozó eszközökkel, scriptekkel való elemzése. A hyres-hírhedt &bdquo;curl-grep&rdquo; stylusú web-API-testelés, ami skálázható-bővíthető a válszok grep helyett a Turing-teljes sed , AWK, Perl vag Raku révén való feldolgozásával. Raku. E híres <em>data-driven</em> nyelvek közptonti foglama egyfajta <q>állapotgép</q>, <q>állapot-automtata</q>, amely egy formális nyelvtant határoz meg, és alkalmas lehet az tesztben elvárt viselkedés, protokoll specifikációjára.</p>
		<p>A legegyszerűbb efféle <q>eldobható</q>, alkalmilag testreszabott tesztelési módszer megvalósítható tiszta bash-scriptekben is_ diff-összehasonlítva a tesztelendő alkalmazásból kifacsart választ elemző szövegfeldolgozó  AWK/Perl/`sed` szriptek kimenetét az előre elkészített etalon/elvárási állományokkal.</p>
		<p>Az alábbi példák a fentiekhez képest egy egyszerűbb helyzetet mutatnak be. Nem webalkalmásnak, hanem egy kis saját szövegesdokumentumgondozó segédszript-rendszer helyességének teszteléséről lesz szó. Az alábbi példák egy kis tesztkeretrendszert mutatnak be egyedi, eseti, nemszabványos helyzetek tesztelésére: nagy HTM és markdown-dokumentumok karbantartását szolgáló szövegátalakító szriptek (pl. automata  tartalomjegyzékgenerálás) helyességének tesztelése, mindez sed, perl, bash eszközök által.</p>
		<ul>
			<li>A worked-out <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts" target="_blank">ad hoc (self-hacked) unit test framework (sub)project</a>, together with its very detailed <a href="https://github.com/alignalghii/alignalghii.github.io/tree/master/aux-scripts#readme">README doc</a>. This auxiliary subproject is  part of this very GitHub Pages personal profile page that You are reading now! It uses Bash, Perl, AWK and sed.  In summary: Sed is a challenging twin and parallel to AWK and Perl, and all these three tools are very versatile for custom task in checking or maintaining texts or streams. Together  with the „glue” / „orchestrating” power of shell scripts (Bash or Perl), this can be organized together into very custom-made ad hoc test framworks adaptable for any imaginable situations.</li>
			<li>Another, a much smaller and less worked-out <a href="https://github.com/alignalghii/client-to-MW-search-API-with-demo-MTs/tree/main/aux-scripts" target="_blank"> (sub)project</a> for a test framework is also an auxiliary part of a bigger project (the already mentioned client program project to the WikiMedia search API). Also its test framework subproject uses Bash, AWK and sed.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Ugrás ez oldal tetejére</a></li>
			<li><a href="index.html#testing">E szakasz angol változata</a></li>
		</ul>
		<hr/>


		<h2 id="math">Matematika, és a hozzá való viszonyom</h2>
		<ul>
			<li><a href="Haskell-and-math.en.html">Haskell and mathematics (and the way I relate to them)</a>. A short personal writing about the topic. How can Haskell and mathematics strengthen each other mutually, and why is it necessary to keep an openness towards the whole of mathematics?</li>
			<li><a href="https://github.com/alignalghii/loosely-coupled-figure-editor/tree/master/floor-plan-designer/doc/haskell" target="_blank">My rather ad-hoc collision detection solution with Fourier-Motzkin elimination</a>. A nicer and cleaner sourcecode could be achieved with Agda, at least for documentation purposes, because vectors and matrices are apt to be represented with dependent-types. <a href="https://github.com/alignalghii/vector-algebra-in-Agda#readme">The already mentioned Agda project for this</a> is still in infancy, having only theorems about the row-and-column algebra of matrices, transposition, arithmetic.</li>
			<li>A proof in category theory, read on Quora, but formalized into  Gentzen-tysle deduction proof tree by myself</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Ugrás ez oldal tetejére</a></li>
			<li><a href="index.html#math">E szakasz angol változata</a></li>
		</ul>
		<hr/>

		<h3 id="selfref">Minták az önhivatkozás témakörében: matematikai, logikai vagy lambda-kalkulusbeli ún. önhivatkozási konstrukciók példái</h3>
		<p>Egy témakör, amely a 2000-es évtized közepe-vége óta foglalkoztat, amelynek a matematikai logikában, de a lambda-kalkulusban is megvan a lenyomata: az <em>önhivatkozás</em> témaköre, a maga paradoxonjaival. A funkcionális programozás terén persze a rekurzív függvények terén jelenik ez meg, ehhez kötődik még az adott nyelv pontos operatív szemantikája, kiértékelésrendje, illeve annak formális modellezése, amely már a topológia területére is átnyúlik.</p>
		<p>E témák terén inkább csak az operatív szematikai elméleti keretekig jutottam, e téren írásaim már nemcsak személyes jellegűek, de tudományosan nem jelentős értékűek, viszont esetleg didaktikus értékük lehet későbbi tovbbfejlesztés során. Létezik benne kisebb saját formalizmus, azonban az viszonylag triviálisan összeszedhető a témát ismerő közöség számára is:</p>
		<ul>
			<li><a href="self-calculus-and-semiself-translation.en.html">A szelf-kalkulus, és a felezett-szelf fordítástechnika</a>: rekurzív függvények megvalósítása a kombinátorlogikában. Heurisztikus út az Y fixpont-kombinátor megvalósításának megértéséhez, általánosításához. Az ún <q>közvetett önhivatkozás</q> (talán Quine írhatta le először logikailag , fizikai kontextusban pedig esetleg Neuman).</li>
			<li><a href="file:///home/physis/Documents/my-blog/alignalghii.github.io/let-rec.en.html">Egy pick  íráspróbálkozásom a híres lusta let-rec szerkezet pontos szemantikájának megadására tiszta lambda-kalkulusban.</a> (a rekurzív let-rec Haskell-változata). A lusta let-rec szerkezet önmagában is fontos, de Swiestra  attribútumnyelvtanokat népszerűsítő cikkének kulcsmozzanata is erre támaszkodik (<q>hitelkártya-művelet</q>, <q>a csomó bezárul</q>).</li>
			<li><a href="https://github.com/alignalghii/practice-preparations-before-learning-attribute-grammars" target="_blank">Személes első lépéseim, tanulási kanyarom</a>  Wouter Swierstra alábbi cikkének megértésében:  <a href="https://wiki.haskell.org/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter">Why attribute grammars matter</a>. Egyben egy kis saját személyes miniprojektet is bemutatok, amelynek feladata, hogy Swiestra cikkének talán legnehezebben érthető és legkülönösebb részét, a <q>csomót bezáró</q> let-rec (luste, rekurzív let-kifejezés) részét megvilágítsa. E kis személyes miniprojektemnek szintén <a href="https://github.com/alignalghii/practice-preparations-before-learning-attribute-grammars#readme">részletes README dokumentációja</a> van.</li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Ugrás ez oldal tetejére</a></li>
			<li><a href="index.html#selfref">E szakasz angol változata</a></li>
		</ul>
		<hr/>

		<h2 id="onliner">Haskell ujjgyakorlataim, <q>egysorosok</q>, kis alapkoncepció-próbálkozások, vagy egyéb csonkprojektecskék</h2>
		<ul>
			<li><a href="https://github.com/alignalghii/lazy-IO-for-pure-functional-interactivity">Lazy IO interactivity and update-hash</a></li>
			<li><a href="https://github.com/alignalghii/tricky-foldr-oneliner-for-a-complex-query">Tricky foldr order</a></li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Ugrás ez oldal tetejére</a></li>
			<li><a href="index.html#onliner">E szakasz angol változata</a></li>
		</ul>
		<hr/>

		<h2 id="webapp">Funkcionális nyelven írt webalkalmazások</h2>
		<ul>
			<li>Mostly cliens-side: <a href="https://github.com/alignalghii/Monty-Hall-problem">Monty Hall problem</a>, example for JavaScript in the declaritve style. See the most functional-style part in the <a href="https://github.com/alignalghii/Monty-Hall-problem/blob/main/js/model.js">model</a> module.  Implemented in Javascript, but inspired by Haskell design concepts. Used implementation techniques: <span class="emcode">Maybe</span> and <span class="emcode">Either</span> algebraic datatypes via Scala-style <em>case object</em>s, <span class="emcode">Monad</span> (and <span class="emcode">Eq</span> etc&hellip;) type classes via PHP-style <em>trait</em>s. In case of JavaScript, all these implemented via <em>prototypal inheritence</em>.</li>
			<li>Mostly server-side: <a>Mini Scotty</a>, a Scotty webmicroframework sample</li>
			<li><a href="https://github.com/alignalghii/functional-design-upon-imperative-substrate">Functional design upon imperative substrate</a> (JavaScript, PHP)</li>
			<li>Both-tiers webapp sample: floor plan designer (frontend) with lightweight user and document ERP (backend).</li>
			<li>Opposite of a web app: a <a href="https://github.com/alignalghii/sample-search-client-paginated-with-monad-transformers">crawler in Haskell with monad transfomers</a></li>
		</ul>
		<hr/>
		<ul class="menu">
			<li><a href="#top">Ugrás ez oldal tetejére</a></li>
			<li><a href="index.html#webapp">E szakasz angol változata</a></li>
		</ul>
		<hr/>

		<h2 id="old-non-hs">My old non-Haskell projects</h2>
		<ul>
			<li><a href="old-projects.html">My old reference works and old projects</a>. Some of my small PHP web apps, with their standalone custom hand-made framework.</li>
		</ul>
		<h2 id="old-hs">My old Haskell projects</h2>
	</body>
</html>
