<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title>&bdquo;Self-calculus&rdquo; and &bdquo;halved-self translation&rdquo;</title>

		<link rel="stylesheet" href="assets/main.css"/>
		<link rel="stylesheet" href="assets/menu.css"/>
		<link rel="stylesheet" href="assets/code.css"/>
		<link rel="stylesheet" href="assets/definition.css"/>

		<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css"/>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/languages/haskell.min.js"></script>
		<script>hljs.highlightAll();</script>
	</head>
	<body>
		<ul class="menu">
			<li><a href="self-calculus-and-semiself-translation.hu.html">Hungarian version of this page</a></li>
			<li><a href="index.html">Back to the main personal page</a></li>
		</ul>
		<h1 id="self-calculus">&bdquo;Self-calculus&rdquo; and &bdquo;halved-self translation&rdquo;</h1>

		<h2 id="table-of-contents">Table of contents</h2>
		<ul>
			<li>
				<a href="#">&bdquo;Self-calculus&rdquo; and &bdquo;halved-self translation&rdquo;</a>
				<ul>
					<li><a href="#">Table of contents</a></li>
					<li>
						<a href="#">Motivation</a>
						<ul>
							<li><a href="#">Bibliography</a></li>
						</ul>
					</li>
					<li>
						<a href="#">Introduction: implementation of recursive functions in lambda calculus</a>
						<ul>
							<li><a href="#">Famous self-referent combinators of lambda calculus</a></li>
							<li><a href="#">Summary of the main thoughts</a></li>
						</ul>
					</li>
					<li><a href="#let-rec">The let-rec construct</a></li>
					<li><a href="#">Special self constant/keyword</a></li>
					<li><a href="#">Special self-abstraction and binding of a self-variable: the self-calculus</a></li>
					<li><a href="#">Combined \(\lambda\) and \(\sigma\) calculus: the \(\lambda\sigma\)-calculus.</a></li>
					<li><a href="#">A naive (invalid, but corrigable) transation technique from self-calculus into lambda-calculus</a></li>
					<li><a href="#">A fordítás javítása</a></li>
					<li><a href="#">The &bdquo;halved-self translation&rdquo; technique</a></li>
					<li><a href="#">Examples</a></li>
				</ul>
			</li>
		</ul>

		<h2 id="motivation">Motivation</h2>

		<p>This writing attempts to present a well-known topics in a maybe novel way. All elements of this writing are better treated in the literature (see below). Still, I let my writing staying, as this has beeen my own personal way to discover the feeling and the experience of the topics for myself and explaining it to myself. Furthermore, as far as I know, self-calculus, originally used in formalization attempts for On years agoOP (Cardelli), has not yet been used in investigating direct and indirect self-reference in such fields of computer science like lambda-calculus, quines, selfreps, recursive functions. This little writing of mine uses a simplified kind of self-calculus as a heuristic missing link between the hard implementations details of indirect self-reference and the informal familiar treatment of the topics &mdash; a kind of heuristic &bdquo;<em>How someone could have invented it as first</em>&rdquo; reconstruction.</p>

		<h3 id="bibliography">Bibliography</h3>

		<ul>
			<li>Daniel Etridge&apos;s &bdquo;<a href="https://medium.com/@dkeout/why-you-must-actually-understand-the-%CF%89-and-y-combinators-c9204241da7a">Why you must actually understand the \(\Omega\) and \(\textbf{Y}\) combinators</a>&rdquo;. I have read this <em>after</em> haveing written this writing, and the treatment is in all aspects better than mine. Still, the novelty of my writing is to use a kind of custom-made &bdquo;self-calculus&rdquo; to explain the topics.</li>
			<li>Nor the idea of some kind of self-calculus is not mine. Almost certain that I had the idea by unconsciously remembering an article series read by me ten years ago. Martín Abadi and Luca Cardelli: &bdquo;<a href="http://lucacardelli.name/Papers/PrimObjImpSIPL.A4.pdf">An Imperative Object Calculus. Basic Typing and Soundness</a>&rdquo;. In this my writing, Cardelli&apos;s self-calculus is skinned down to be simpler to be adapted to the simple core questions of lambda-calculus. No OOP concepts are needed.</li>
			<li>The focus about direct vs indirect self-reference, and its biological analogies, and its importance in mathematical logics and paradoxes: all these topics come from papers like <a href="https://www.scientificamerican.com/article/go-forth-and-replicate-2008-02/">self-reproduction machine</a> of Conway&apos;s cellular automata, and also from David Madore&apos;s article on <a href="http://www.madore.org/~david/computers/quine.html">Quines (self-replicationg programs)</a></li>
			<li>The formalism of lambda calculus, notations, concepts come from Dr Csörnyei Zoltán &apos;s book &bdquo;<a href="https://www.interkonyv.hu/konyvek/Lambda%20kalkulus/">Lambda-kalkulus. A funkcionális programozás alapjai</a>&rdquo;</li>
		</ul>

		<h2 id="introduction">Introduction: implementation of recursive functions in lambda calculus</h2>

		<p>For beginners who are at their beginnings steps at learning lambda calculus, the mathematical foundation of functional programming, it may seem hard to understand how recursive functions can be defined with the seemingly rather Spartan and limited toolkit of lambda calculus. Lambda calculus may seem to lack the necessary expressive power to define recursive functions. Although there is an explicit notation for the notion of parameter in the syntax of this minimalistic language formalism, but there is no explicit way to express the notion of <em>self</em>: we cannot repeat the name of the freshly defined function in the definition body, since lambda calculus totally lacks any notion of named functions at all. In summary: there is no way to express self-reference explicitly.</p>
		<p>Practical functional languages can define self-refrence easily, since they can define named functions. Lambda calculus lacks named functions, still, it can define recursive function, by a technique called implicit or indirect self-reference. Understanding this is a very steep step, a part of the hard learning curve.</p>
		<p>In practical functiona programming languages the  function definition is usually combined with name-giving, a very expressive tool enabling direct self-reference. This can be done either globally:</p>
		<pre><code class="language-haskell">fac n = if n == 0
    then 1
    else n * fac (n - 1)</code></pre>
		<p>or locally:</p>
		<pre><code class="language-haskell">let fac n = if n == 0
                then 1
                else n * fac (n - 1)
in fac 5</code></pre>
		<p>in either cases, the self-reference is explicit/direct: the definition body can simply refer to the name itself that is just being defined. And it is exactly this kind of (direct/explicit) self-reference that is lacking in pure lambda calculus:</p>
		\[
			\boxed{\textbf{fac}} :\equiv \lambda n. \left(\mathbf{greaterThan}\ n\ 0\right) \Bigg(\mathbf{times}\ n\ \left(\boxed{\mathbf{fac}} \left(\mathbf{minus}\ n\ 1\right)\right) 1\Bigg)
		\]

		<p>the above expression is <em>invalid</em> in pure lambda-calculus, because any such kind of named definition, name-giving is not a part of the object language of the lambda-calculus, only a part of the metalanguage surrounding it, thus, not a lambda term on its own! In short, the concept of &bdquo;<em>self</em>&rdquo; is not a first-class citizen in this language formalism.</p>
		<p>Can it be encoded or simulated somehow, in some indirect, implicit way? Lambda calculus is suprprisingly expressive: it can booleans,  represent numbers (Church numerals), finite algebraic datatypes. Can it represent recursive functions (and recursive datatypes) too? But how to achieve the seemingly lacking capability of self-reference?</p>
		<p>People who have an interest in biological analogies know about a kind of <em>indirect</em>/<em>implicit</em> self-reference in programming, manifested in the <a href="https://www.scientificamerican.com/article/go-forth-and-replicate-2008-02/">self-reproduction machine</a> of Conway&apos;s cellular automata, following very strong biological analogies. The main idea is that Conway&apos;s self-replication machine contains a kind of DNA part, which can govern assemblage. The machine assemblages its own copy by following the rules encoded in its own DNA. By how is replicated the DNA part? It cannot contain itself! But it does not need to contain itself. The DNA part is simply copied. Self-replication can be down partly by rule-governed assemblage, partly by simple copying of the rule tape. This kind-of self-replication does not need an explicit, direct self-concept: the concept of self is implemented implicitly, in an emergent way.</p>
		<p>The same idea is realized in the so-called <em>quine</em>s, or <em>self-reps</em>: programs that can print out their own sourcecode listing without resorting to any direct (operating-system misusing) tool. Quines are based on the idea of self-quotation, a logical approach very similar and related to the diagonal argument and to many logical paradoxes. See David Madore&apos;s article on <a href="http://www.madore.org/~david/computers/quine.html">Quines (self-replicationg programs)</a>.</p>
		<p>In this writing, these interesting achievements of the 20th century mathematics are not mentioned any deeper, and only some thoughts restricted to the realm of lambda-calculus will be presented.</p>


		<h3 id="selfrep-combinators">Famous self-referent combinators of lambda calculus</h3>

		<p>Even before You meet the topics of recursive functions, You may have met the famous self-referent combinators of lambda calculus: they are usually mentioned as examples for topics in evalation strategies and divergence. The main point about these combinators are easy to explain, yet they may look like sort of paradoxical for the beginner. Most notably, the  \(\Omega\) divergence combinator and the \(\textbf{Y}\) fixkombinátor can be regarded as self-referent. For beginners, it is eay to explain what they are expected to behave like, but it is much harder to explain how they can be realized/implemented (how they achieve their working exactly). Their expected reduction behavior is:</p>
		\[
			\Omega\;\;\rhd_\beta^+\;\;\Omega\;\;\rhd_\beta^+\;\;\Omega\;\;\rhd_\beta^+\;\;\Omega\;\;\rhd_\beta^+\;\;\dots
		\]
		<p>this was a combinator simply to demostrate divergence. Much more useful is the fixed-pont combinator:</p>
		\[
			\textbf{Y}\ f\;\;\rhd_\beta^+\;\;f\ \left(\mathbf{Y}\ f\right)
		\]
		<p>Their expected reduction behavior is clear now &mdash; but can they be realized at all? We know from the prominent books and articles about lambda calculus, how they are defined (definitions by Curry, Church):
		\[
			\begin{aligned}
				\Omega     &\equiv \left(\lambda z. z z\right) \left(\lambda z. z z\right)\\
				\textbf{Y} &\equiv \lambda f.\Big(\lambda z. f\left(z z\right)\Big) \Big(\lambda z. f\left(z z\right)\Big)
			\end{aligned}
		\]
		<p>if we already know that, we can prove even by paper-and-pancil that the above definitions indeed satisfy the expected behaviors. (Moreover, \(\Omega\) achieves that even with a single \(\rhd_\beta\) reduction step to transform itself into itself own, which may sound paradoxical at first, but it is trivial to see by pen-and paper.)</p>
		<p>For the <span class="combinator">Y</span> combinator also an alternative definition would be appropriate, like this (prove it by reducing it on paper by pencil):</p>
		\[
			\textbf{Y} \equiv \Big(\lambda z f. f\left(z z f\right)\Big) \Big(\lambda z f. f\left(z z f\right)\Big)
		\]
		<p>De vajon hogyan lehet első ízben arra rájönni, felfedezni, hogy ez a megfelelő megvalósítás? Talán egy kicsit segít, ha legalább valami tapogatozó fogalomnevet adunk az egész, illetve annak összetevő részkifejezéseinek, és a változó maga is beszédesebb nevet kap:</p>
		\[
			\begin{aligned}
				\Omega     &\equiv \underbrace{\left(\underbrace{\lambda s^{\frac12}. s^{\frac12} s^{\frac12}}_{\textbf{semiself}}\right) \left(\underbrace{\lambda s^{\frac12}. s^{\frac12} s^{\frac12}}_{\textbf{semiself}}\right)}_{\textbf{self}}\\[9pt]
				\textbf{Y} &\equiv \underbrace{\Bigg(\;\underbrace{\lambda s^{\frac12} f. f\left(s^{\frac12} s^{\frac12} f\right)}_{\textbf{semiself}}\;\Bigg) \Bigg(\;\underbrace{\lambda s^{\frac12} f. f\left(s^{\frac12} s^{\frac12} f\right)}_{\textbf{semiself}}\;\Bigg)}_{\textbf{self}}
			\end{aligned}
		\]
		<p>The meaning of all these little <em>ad hoc</em> auxiliary notionsof ours: \(\textbf{self}\) is intended to mean the term just being defined, i.e. the &bdquo;definiendum&rdquo;, the whole complete term being &bdquo;born&bdquo; when the definition process goes into completion. But <em>self-reference</em> has no explicit, syntactically and semantically <em>first-class citizen</em> way to be expressed.Still we can achieve the same expressive power by falling back to the method of <em>indirect (implicit) self-refereence</em>: this is sort of related to Cantor&apo;s famous diagonal argument, a spiritual heir of the same thought. The main idea is that we can express the self by forming it as an application of a subexpression/subterm (&bdquo;semiterm&rdquo;) onto itself. This is what we will call a \(\textbf{semiself}\): a semiself is exactly such a kind of a semiterm intended later to be applied onto itself in order to form a complete whole  \(\textbf{self}\).</p>
		<p>This will be the main point and idea of this small article, of course discussed a little more formally and in a little more details. Our self-referent &bdquo;self&rdquo; expressions are all implemented a some self-application of a corresponding &bdquo;semiself&rdquo;, their correctness and validity can be seen and proven simply by well-known via beta-reduction, even simply by pen-and-paper. For more laic-friendly notation convention, a lambda-variable binding a semi-felf will be notated as \(s^{\frac12}\). The motivation behind this notation is that any occurrence of a self-applying \(s^{\frac12} s^{\frac12}\) subterm is ment to &bdquo;fuse&rdquo; into a complete \(s\), memorize it by the following analogies: &bdquo;semiself + semiself = self&rdquo; and &bdquo;\(s^{\frac12} + s^{\frac12} = s = \textbf{self}\)&rdquo;:</p>
		\[
			\begin{aligned}
				\Omega     &\equiv \left(\lambda s^{\frac12}. \underbrace{\boxed{s^{\frac12} s^{\frac12}}}_{s\;=\;\textbf{self}}\right) \left(\lambda s^{\frac12}. \underbrace{\boxed{s^{\frac12} s^{\frac12}}}_{s\;=\;\textbf{self}}\right)\\[9pt]
				\textbf{Y} &\equiv \Bigg(\;\lambda s^{\frac12} f. f\Big(\;\underbrace{\boxed{s^{\frac12} s^{\frac12}}}_{s\;=\;\textbf{self}} \;f\Big)\Bigg) \Bigg(\;\lambda s^{\frac12} f. f\Big(\;\underbrace{\boxed{s^{\frac12} s^{\frac12}}}_{s\;=\;\textbf{self}} \;f\Big)\Bigg)
			\end{aligned}
		\]
		<p>Although all these above can be a mnemotechnical help, but  still, all these fail to explain the heuristic path: how did scolars first find out the way to express recursive functions and self-referenc combinators in lambda-calculus? It seems easy to check the definitions, but it seems hard to invent them from scratch. Although i do not know the history of these invention process, but I know my own personal way: so I try to explain my own personal experiences.</p>
	<p>This personal path of mine is very probably not valuable in the scientific sense: it is almost sure that many other people have invented the same on their own, moreover, there is a good chance that my &bdquo;inventions&rdquo; have been formed by my semi-forgotten reader experiences about Luca Cardelli&apos; &bdquo;object calculus&rdquo; (e.g. Martín Abadi and Luca Cardelli: &bdquo;<a href="http://lucacardelli.name/Papers/PrimObjImpSIPL.A4.pdf">An Imperative Object Calculus. Basic Typing and Soundness</a>&rdquo;). Despite of that, this writing is not based directly on Cardelli&apos;s papers: my memories have been very old and unconscious by the time of preparing this writing, thus the thoughts presented here are at least transformed by personal struggle along the learning curves.</p>

		<h3 id="summary-thoughts">Summary of the main thoughts</h3>

		<p>In this writing, we will proceed in three steps: we make several custom mini-languages refining them in stages, making it &bdquo;purer&rdquo; and &bdquo;purer&rdquo; until it reaches the simplicity of lambda calculus itself.</p>
		<ol>
			<li>The first mini-language will be simply Haskell&apos;s <span class="emcode">let</span>&hellip;<span class="emcode">in</span>&hellip; construct. Its semantics is is much more simpler than that of the entire Haskell language (it can be regarded as a sort of core), and it can be tackled well mathematically. It is still too big to be regarded as a calculus language in the logical sense, still, it is a good intermediate towards that. Haskell&apos;s <span class="emcode">let</span>&hellip;<span class="emcode">in</span>&hellip; construct belongs to what we call the &bdquo;<em>let-rec</em>&rdquo; construct generally in functional programming, i.e. the recursive let-construct. Specifically for Haskell, it is the <em>lazy</em> nature of the <span class="emcode">let</span>&hellip;<span class="emcode">in</span>&hellip; construct that enables it to define more than simple local variables and term substitution: it has the expressive power to define recursion and self-reference directly. This kind-of let-rec calculus can be regarded either as a very small programming language or as a bloated-up mathematical calculus. We will proceed by making in slimmer and slimmer.</li>
			<li>Our next step will be skimming the above let-rec-calculus into a much more mathematical-style &bdquo;<em>self-calculus</em>&rdquo;, where the notion of &bdquo;self&rdquo; is a frst-class citizen. we show some examples for its use.</li>
			<li>Afterwards, we will demonstrate that such a &bdquo;self-calculus&rdquo; is just a syntactic sugar: it does not transcend pure lambda calculus in expressive power. We will present a technique (&bdquo;<em>halved-self translation</em>&rdquo;) that translates self-calculus to pure lambda calculus.</li>
		</ol>
		<p>After all that, we will see that &bdquo;halved-self translation&rdquo; is a rather expensive technique in terms of compactness, thus we will &bdquo;factor out&rdquo; the complicated part into a common function, (which will turn out to be the famous Y fixed-point combinator). thus separateing the wary parts in the name of conceptual modularity and reuse. In short: Y will be defined via  the &bdquo;halved-self translation&rdquo; technique, and any other recusrive functions will be defined via the <span class="combinator">Y</span> combinator.</p>


		<h2 id="let-rec">The let-rec construct</h2>
		<p>In more details, I wrote <a href="let-rec.hu.html">its own dedicated page</a>, explaining the mathematics behind it.</p>
		<p>Example for using the lazy let-rec for defining the factorial recursive function:</p>
		<pre><code class="language-haskell">let fac n = if n == 0
                then 1
                else n * fac (n - 1)
in fac 5</code></pre>
		<p>Let us also show examples for the famous self-referent combinators encoded in the let-rec construct:</p>
		<pre><code class="language-haskell">let omega = omega in omega</code></pre>
		<p>&hellip;not very useful in practice, as it is diverging. Let us see the more useful <span class="combinator">Y</span> fixed-point combinator defined locally with the let-rec construct, and let us build up the recursivity of factorial function with it:</p>
		<pre><code class="language-haskell">let y f = f (y f)
in y   (
            \self n -> if n > 0
                           then n * self (n - 1)
                           else 1
       )</code></pre>

		<h2 id="self-keyword">Special self constant/keyword</h2>

		<p>Although the let-rec construct shown above is still a rather complicated formalism, lacking the pureness and mathematical versatility of a logical calculus, we can already have an idea how to make a kind of self-calculus and direct self-reference.</p>
		<p>The main idea is simple: let us use a special reserved \(\boxed{\boxed{\boxed{\textbf{SELF}}}}\) symbol at the location of self-reference to denote the very act of selfreference! This is not a very dep solution with any mathematical insights, still, it is good for exploring the prossibilities in first round.</p>
		<p>Let us see an example for a familiary recursive function, e.g. the well-known factorial function from school math:</p>
		\[
			\underbrace{
				\lambda n\ .\
					\left(
						\textbf{greaterThan}\ n\ \textbf{0}
					\right)
					\Bigg(
						\textbf{times}\ n
						\left(
							\boxed{\boxed{\boxed{\textbf{SELF}}}} \left(\textbf{minus}\ n\ \textbf{1}\right)
						\right)
					\Bigg)
					\textbf{1}
			}_{\textbf{fac}}
		\]
		<p>Let us see also simpler examples, e.g. the famous self-referenct combinators of lambda-calculus, implemented with this reserved (\boxed{\boxed{\boxed{\textbf{SELF}}}}\) symbol notation formalism:</p>
		\[
			\begin{aligned}
				\Omega     &\equiv \boxed{\boxed{\boxed{\textbf{SELF}}}}\\
				\textbf{Y} &\equiv \lambda\ f\ .\ f\left(\boxed{\boxed{\boxed{\textbf{SELF}}}} f\right)
			\end{aligned}
		\]
		<p>We can say in a polite way with euphemism, that this symbolism could not yield too much insight, abstracton and deeper understanding, and did not help much to invent the idea how to express self-reference in pure lambda calculus. Despite of this weaknesses, this was a first step and we can continue stepping further in this spirit, exploring the pure mathematics behind self-reference and finding how pure math can provide an indirect, implicit way to express it by pure means.</p>


		<h2 id="self-abstractor">Special self-abstraction and binding of a self-variable: the self-calculus</h2>

		<p>Our next idea can be, that instead of usage of a reserved \(\boxed{\boxed{\boxed{\textbf{SELF}}}}\) keyword symbol, it would be more &bdquo;mathematical&rdquo; to introduce a self abstractor, entirely to the analogy of lambda-calculus:</p>
		<ul>
			<li>
				<span>In lambda-calculus, a \(\lambda\) abstractor binds a variable, that gets value by later parameter-passing (\(beta\)-reduction)</span>
				\[
					\left(
						\lambda x . \Phi
					\right)
					\Psi
					\;
					\rhd_\beta
					\;
					\Phi
					\left[
						\frac\Psi x
					\right]
				\]
			</li>
			<li>
				<span>To the complete analogy of this, we would introduce a \(\sigma\) abstactor, binding a variable, that gets value by identifying it with the entire term itself (a so-called &bdquo;self-abstraction&rdquo; or \(sigma\)-reduction).</span>
				\[\sigma s.\Phi\;\;\rhd_\sigma\;\;\Phi\left[\dfrac{\sigma s.\Phi}{s}\right]\]
			</li>
		</ul>
		<p>
			In short, we make a fist-class citizen notion (and notation) to express th concept of &bdquo;self&rdquo; explicitly and directly.
			This is a big leap forward: this is at last a <em>calculus</em> in the mathematical sense:
			there are very clear and minimalistic syntactical rules and semantical interpretations, and we can achieve good mathematical rigor with that.
		</p>
		<p>In plain English: the \(sigma\)-operator can bind a variable (here in the example: a variable \(s\), talking name \(s\) for &bdquo;self&rdquo;), and inside its local scope \(Phi\) any \(s\)-occurance should be substituted for the entire original expression \(\sigma s.\Phi\). We have grasped the very essence of the self-concept with that, both in syntax and semantics.</p>

		<p>This \(sigma\)-calculus in ts purest for is not very expressive, but we can already define the already mentioned \(\Omega\) combinator in it:
		\[
			\Omega \;\equiv\; \sigma s. s
		\]
		<p>This is exaclty that what enables \(\Omega\) to satisfy its expected sematical behavior:</p>
		\[
			\Omega\;\;\rhd_\beta^+\;\;\Omega\;\;\rhd_\beta^+\;\;\Omega\;\;\rhd_\beta^+\;\;\Omega\;\;\rhd_\beta^+\;\;\dots
		\]
		<p>For more complex examples, we will have to combine \(\lambda\) and \(\sigma\) calculus into a sort of combined \(\lambda\sigma\)-calculus.</p>
		<p>Ennek alapötlete az, hogy amiként a lambda-kalkulusban a lambda-operátor képes változót megkötni, és hatáskörén belül azt afféle lokális változóként bevezetni, amihez aztán a béta-redukció során &bdquo;érték&rdquo; is köthető, ennek mintájára, analógiájára bevezethetnénk a lmandához hasonló operátort, mondjuk egy \(\sigma\)-operátort, amelyet teljesen a lambadoperátor mintjájára használnánk.</p>

		<h2 id="combined-lambda-self-calculus">Combined \(\lambda\) and \(\sigma\) calculus: the \(\lambda\sigma\)-calculus.</h2>
		<p>We can comnine both abstractors freely in a common formal grammar framework, a combined calculus, where syntac contains both \(\lambda\) and \(\sigma\) abstractors, and semantics contains both (\beta\)-reduction and \(\sigma\)-reduction.</p>
		<p>Best example for the combined usage: the two possible alternative ways for the famous fixed-point combinator:</p>
		\[
			\begin{aligned}
				\textbf{Y}_{\textbf{Curry}}  &\;\;\equiv\; \lambda f. \sigma  s. fs              \\
				\textbf{Y}_{\textbf{Turing}} &\;\;\equiv\; \sigma  s. \lambda f. f\left(sf\right)
			\end{aligned}
		\]
		<p>Of course, they did not use that notation, we will see later the correspondence by the semi-self translation technique. In the literature, \(\textbf{Y}_{\textbf{Curry}}\) is usually denoted simply \(\textbf{Y}\), and \(\textbf{Y}_{\textbf{Turing}}\) is denoted as \(\Theta\).</p>
		<p>syntactically \(\textbf{Y}_{\textbf{Curry}}\)  looks simpler, but despite of that, after having been translated to their pure lambda-calculus form, it is \(\textbf{Y}_{\textbf{Turing}}\) that has a much simpler semantics. \(\textbf{Y}_{\textbf{Curry}}\) makes use of an additional \(\eta\)-conversion. See Dr Csörnyei Zoltán &apos;s book &bdquo;<a href="https://www.interkonyv.hu/konyvek/Lambda%20kalkulus/">Lambda-kalkulus. A funkcionális programozás alapjai</a>&rdquo;, section 5.2 (pages 88-90).</p>
		<p>In both cases, the expected behavior is this: for any term \(f\)</p>
		\[
			\textbf{Y} f = f \left(\textbf{Y} f\right)
		\]
		<p>where, the = symbol denotes reflexive, symmetric, and transitive closure of either \(\beta\)- or \(\sigma\)-reductions.</p>
		<p>Lenne egy szintaktikai és egy szemantikai különbség:</p>
		<dl>
			<dt>Szemantikailag:</dt>
			<dd>
				Ha a \(\sigma\)-operátorral lekötünk egy \(s\)-változót valamilyen, az operátor hatáskörében álló \(\Phi\) kifejezésre, akkor az \(s\) minden \(\Phi\)-beli előfordulása helyébe a &bdquo;szelfet&rdquo; kell érteni, tehát a <em>teljes</em> \(\sigma s.\Phi\) kifejezést! Egyszóval, a \(\sigma\) operátor valóban a <em>közvetlen, explicit</em> önhivatkozás lehetőségét teremti meg! Formalizáltan ezt úgy rögzíthetjük, hogy bevezetünk egy \(\rhd_\sigma\) redukciófogalmat, amelynek szabálya:
				\[\sigma s.\Phi\;\;\rhd_\sigma\;\;\Phi\left[\dfrac{\sigma s.\Phi}{s}\right]\]
			</dd>
			<dt>Szintaktikailag:</dt>
			<dd>szintaktikailag igazából nem lenne semmi plusz megkötés, szabadon kombinálhatóak a szigma- és a labda-operátorok a nekik megfelelő szabályok szerint, de ez konrétan azt jelenti, hog a \(\sigma\)-kifejezésre <em>nem</em> értelmezünk <em>(függvény)alkalmazás</em>-műveletet, vagyis argumentumként expliciten átadott értéket. Pontosabban formalizálva: a \(\sigma\)-kifejezésre nincs beta-redukció, csak a fent említett &bdquo;szigma-redukció&rdquo;. itt konkrétan ebben az írásban a \(\sigma\)-operátor mindig a legkülső operátor lesz (talán ennél elképzelhető általánosabb felállás is, de itt ez is elég lesz).</dd>
		</dl>
		<p>Nézzünk példákat. Elsőnek egy bonyolult példa: rekurzív függvény kifejezése, mégpedig az iskolából  ismert faktoriális-függvényé:</p>
		\[
			\underbrace{
				\sigma\ \boxed{s}\ .\
					\lambda n\ .\
						\left(
							\textbf{greaterThan}\ n\ \textbf{0}
						\right)
						\Bigg(
							\textbf{times}\ n
							\Big(
								\boxed{s} \left(\textbf{minus}\ n\ \textbf{1}\right)
							\Big)
						\Bigg)
						\textbf{1}
			}_{\textbf{fac}}
		\]

		<p>Itt is nézzük meg egyszerűbb felépítésű példák gyanánt a híres-hírhedt önhivatkozó kombinátorokat:</p>
		\[
			\begin{aligned}
				\Omega     &\equiv \left[\!\left[\sigma\ s\ .\ s\right]\!\right]\\
				\textbf{Y} &\equiv \left[\!\left[\sigma\ s\ .\ \lambda\ f\ .\ f\ \left(s\ f\right)\right]\!\right]
			\end{aligned}
		\]
		<p>
			Az utóbbi kettőnél nézzük is meg, vajon tényelg jól, az elvárt módon viselkednek-e a rendukció tényleges végrehajára során?
			Bonyolultabb levezetéseknél soronként egyetlen szabály alkalmazása fog szerepelni.
			Minden egyes szabály elsütésének bal- és jobboldalán is aláhúzás fogja jelölni a szabály által érintett ráilleszkedő bemeneti és kimeneti <em>redex</em>et. A redex (vagyis az aktuális redukciós szabályra közvetlenül ráilleszkedő részkifejezés) aláhúzással való megjelölésének ötletét, a levezetés ily módon való olvashatóbbá tevését Dr. Csörnyei Zoltán „<a href="https://www.interkonyv.hu/konyvek/Lambda%20kalkulus/">Lambda-kalkulus. A funkcionális programozás alapjai</a>” c. könyvéből vettem (azzal a pici módosítással, hogy a redukció utáni kifejezésben is megjelölöm az érintett &bdquo;kimeneti&rdquo; redexet).
		</p>
		<p>\(\Omega\)-kombinátor szigma-kalkulusbeli változata esetében:</p>
		\[
			\sigma s.s \;\;\rhd_\sigma\;\; \sigma s.s \;\;\rhd_\sigma\;\; \sigma s.s \;\;\rhd_\sigma\;\; \sigma s.s \;\;\rhd_\sigma\;\; \sigma s.s \;\;\rhd_\sigma\;\; \dots
		\]
		<p>ez megfelel az \(\Omega\)-kombinátor elvárt operacionális szemantikájának (divergáló, deminden lépésben redukálódó önmagába &bdquo;redukálódó&rdquo;).</p>
		<p>Lássuk a másik önhivatkozó kombinátor, az <span class="combinator">Y</span> viselkedését, konrétan valamely \(F\) argumentummal:</p>
		\[
			\begin{matrix}
				\textbf{Y}\ F                                                              &               &  &  & \\[6pt]
				|||                                                                        &               &  &  & \\[9pt]
				\overbrace{\underline{\Big(\sigma s\lambda f.f(sf)\Big)}}^{\textbf{Y}}\ F  &  \rhd_\sigma  & \underline{\bigg(\lambda f.f\Big(\overbrace{\big(\sigma s\lambda f^\prime.(sf^\prime)\big)}^{\textbf{Y}}\ f\Big)\bigg)}\ F  &  & \\[6pt]
				& & |||  &  & \\[6pt]
				& & \underline{\bigg(\lambda f.f\Big(\overbrace{\big(\sigma s\lambda f^\prime.(sf^\prime)\big)}^{\textbf{Y}}\ f\Big)\bigg)\ F}  &  \rhd_\beta  &  \underline{F\Bigg(\overbrace{\Big(\sigma s\lambda f^\prime.(sf^\prime)\Big)}^{\textbf{Y}}\;F\Bigg)} \\[8pt]
				& & & & ||| \\[8pt]
				& & & & F\left(\textbf{Y}\ F\right)
			\end{matrix}
		\]

		<h2 id="naive-translation">A naive (invalid, but corrigable) translation technique from self-calculus into lambda-calculus</h2>

		\[
			\Bigg(
				\underbrace{
					\lambda\ \boxed{s}\ .\
						\lambda n\ .\
							\left(
								\textbf{greaterThan}\ n\ \textbf{0}
							\right)
							\bigg(
								\textbf{times}\ n
								\Big(
									\boxed{s} \left(\textbf{minus}\ n\ \textbf{1}\right)
								\Big)
							\bigg)
							\textbf{1}
				}_{\textbf{fac}}
			\Bigg)
			\Bigg(
				\underbrace{
					\lambda\ \boxed{s}\ .\
						\lambda n\ .\
							\left(
								\textbf{greaterThan}\ n\ \textbf{0}
							\right)
							\bigg(
								\textbf{times}\ n
								\Big(
									\boxed{s} \left(\textbf{minus}\ n\ \textbf{1}\right)
								\Big)
							\bigg)
							\textbf{1}
				}_{\textbf{fac}}
			\Bigg)
		\]
		<p>innen \(\beta\)-redukcióval</p>

		\[
			\underbrace{
				\lambda n\ .\
					\left(
						\textbf{greaterThan}\ n\ \textbf{0}
					\right)
					\bigg(
						\textbf{times}\ n
						\Big(
							\boxed{\textbf{fac}} \left(\textbf{minus}\ n\ \textbf{1}\right)
						\Big)
					\bigg)
					\textbf{1}
			}_{\boxed{\textbf{fac}}}
		\]

		<p>Ha ezt átgondoljuk, kiderül, hogy ez az irány nem jó. Aznban a faktoriális mint rekurzív függvény kissé túl összetett, nézzük meg itt  híres-hírhedt önhivatkozó kombinátorok példáján mint egyszerűbb felépítésű példán, mi is az, ami nem jó:</p>

		\[
			\begin{aligned}
				\Omega
				&\equiv
				\underbrace{
					\left(
						\lambda\ s\ .\ s
					\right)
				}_{\textbf{self}}
				\;
				\underbrace{
					\left(
						\lambda\ s\ .\ s
					\right)
				}_{\textbf{self}}

				\\

				\textbf{Y}
				&\equiv
				\underbrace{
					\Big(
						\lambda\ s\ f\ .\ f\ \left(s\ f\right)
					\Big)
				}_{\textbf{self}}
				\;
				\underbrace{
					\Big(
						\lambda\ s\ f\ .\ f\ \left(s\ f\right)
					\Big)
				}_{\textbf{self}}
			\end{aligned}
		\]

		<p>Nézzük meg, jók-e ezek: írjuk fül ki rendre az \(\Omega\) redukciós lépéssorozatát, és az \(\textbf{Y}\ f\) kifejezés redukciós lépéssorozatát is! Úgy viselkedik-e a redukció, ahogy ezektől az önrhivatkozó kombinátoroktól elvárnánk?</p>
		\[
			\Omega
			\;\;\equiv\;\;
			\left(
				\lambda\ s\ .\ s
			\right)
			\left(
				\lambda\ s\ .\ s
			\right)
			\;\;\rhd_\beta\;\;
			\lambda\ s\ .\ s
		\]
		<p>Hát az \(\Omega\) nem. Ez egyetlen lépésben terminált, az igazi \(\Omega\)-nak végtelenségig kellene tartania a redukcióknak. Lássuk most az \(\textbf{Y}\ f\) kifejezés redukciós lépéssorozatát:</p>
		\[
			\textbf{Y}\ f
			\;\;\equiv\;\;
			\Big(
				\lambda\ s\ f\ .\ f\ \left(s\ f\right)
			\Big)
			\Big(
				\lambda\ s\ f\ .\ f\ \left(s\ f\right)
			\Big)
			\ f
			\;\;\rhd_\beta\;\;
			f\
			\Bigg(
				\Big(
					\lambda\ s\ f\ .\ f\ \left(s\ f\right)
				\Big)\
				f
			\Bigg)
			\;\;\rhd_\beta\;\;
			f\
			\bigg(
				\lambda\ f\ .\ f\ \left(f\ f\right)
			\bigg)
		\]

		<p>Láthatjuk, hogy az \(\textbf{Y}\ f\) kifejezés redukciós lépéssorozata sem az elvárás szerinti.</p>
		<p>Tehát jó-e mindez? <em>Nem!!!</em> Hamarosan kiderül, miért nem az, de egyelőre nézzük meg, mi lenne a folyománya, ha jó lenne.</p>

		<p>Ha ez jó lenne (nem az!), akkor már írhatnánk is fel a már alakra is szép, egyszerű általános fordítási szabályt szelf-kalkulusról ,,tiszta'' lambda-kalkulusra: testszőleges \(\sigma s.\Phi\) szelf-kalkulus kifejezésre</p>
		\[
			[\![\sigma s. \Phi]\!]
			\equiv
			\underbrace{
				\left(
						\lambda s. \Phi
				\right)
			}_{\textbf{self}}
			\
			\underbrace{
				\left(
					\lambda s. \Phi
				\right)
			}_{\textbf{self}}
		\]

		<p>Majdnem jó gondolatmenet, de egy javítható részletben mégis hibás. Még nem illeszkednek össze hézagmentesen a részletek. valójában a definiálandó \(\textbf{fac}\) nem rendre a két-két részkifejezés, hanem a két részkifejezésből alkotott teljes nagy kifejezés lenne! Valahogy így:</p>
		\[
			\underbrace{
				\Bigg(
					\underbrace{
						\lambda\ \boxed{s}\ .\
							\lambda n\ .\
								\left(
									\textbf{greaterThan}\ n\ \textbf{0}
								\right)
								\bigg(
									\textbf{times}\ n
									\Big(
										\boxed{s} \left(\textbf{minus}\ n\ \textbf{1}\right)
									\Big)
								\bigg)
								\textbf{1}
					}_{\textbf{fac}^{\frac12}}
				\Bigg)
				\Bigg(
					\underbrace{
						\lambda\ \boxed{s}\ .\
							\lambda n\ .\
								\left(
									\textbf{greaterThan}\ n\ \textbf{0}
								\right)
								\bigg(
									\textbf{times}\ n
									\Big(
										\boxed{s} \left(\textbf{minus}\ n\ \textbf{1}\right)
									\Big)
								\bigg)
								\textbf{1}
					}_{\textbf{fac}^{\frac12}}
				\Bigg)
			}_{\textbf{fac}}
		\]
		<p>A kívánt faktoriális-függvény (\(\textbf{fac}\)) tehát a teljes nagy kifejezés, ő itt a ,,szelf''. A két részkifejezés nem maga a kívánt \(\textbf{fac}\) nem ők játsszák a szelf szerepét, ők afféle ,,szemiszelf'', és jelölésben is különböztessük meg valamiféle rendszerezett módon: jelöljük úgy, hogy \(\textbf{fac}^{\frac12}\), a kis feles-kitevő különböztesse meg mindig a félkifejezést az egésztől, a szemiszelfet a mindenkori szelftől!</p>
		<p>Általános módon felírva valahogy így:</p>
		\[
			[\![\sigma s. \Phi]\!]
			\equiv
			\underbrace{
				\underbrace{
					\left(
							\lambda s. \Phi
					\right)
				}_{\textbf{semiself}}
				\
				\underbrace{
					\left(
						\lambda s. \Phi
					\right)
				}_{\textbf{semiself}}
			}_{\textbf{self}}
		\]
		<p>vagy tömörebben, a &bdquo;\(\textbf{semiself}\)&rdquo; helyett a tömörebb és a modulárisabb \(\textbf{self}^{\frac12}\) jelöléssel:</p>
		\[
			[\![\sigma s. \Phi]\!]
			\equiv
			\underbrace{
				\underbrace{
					\left(
							\lambda s. \Phi
					\right)
				}_{\textbf{self}^{\frac12}}
				\
				\underbrace{
					\left(
						\lambda s. \Phi
					\right)
				}_{\textbf{self}^{\frac12}}
			}_{\textbf{self}}
		\]


		<h2 id="mend-translation">A fordítás javítása</h2>

		<p>
			Ezek azonban még mindig nem a jó kifejezések, hiszen tulajdonképp magukon a kifejezéseken nem is változtattunk semmit, éppen csak a kapcsos magyarázó jelek pontosításával rámutattunk a hibára.
			A hiba végső oka az, ahogy a \(\beta\)-redukciót ténylegesen elvégezzük, kiderül,
			hogy ahol a szelfet várnánk el, oda pont a szemiszelf kerül, pont nem illeszkedik össze a gondolatmenet.
		</p>
		<p>
		</p>

		<h2 id="halved-self-translation">The &bdquo;halved-self translation&rdquo; technique</h2>
		\[
			[\![\sigma s. \Phi]\!]
			\equiv
			\underbrace{
				\left(
					\underbrace{
						\lambda s^{\frac12}. \Phi\left[\frac{s^{\frac12} s^{\frac12}}{s}\right]
					}_{\textbf{semiself}}
				\right)
				\left(
					\underbrace{
						\lambda s^{\frac12}. \Phi\left[\frac{s^{\frac12} s^{\frac12}}{s}\right]
					}_{\textbf{semiself}}
				\right)
			}_{\textbf{self}}
		\]

		<h2 id="examples">Examples</h2>

	</body>
</html>
